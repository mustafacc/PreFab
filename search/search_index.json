{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Installation","text":"<p>PreFab leverages deep learning to model fabrication-induced structural variations in integrated photonic devices. Through this virtual nanofabrication environment, we uncover valuable insights into nanofabrication processes and enhance device design accuracy.</p> <p>This guide will get you all set up and ready to use PreFab to predict the fabrication-induced structural variations of your own integrated photonic devices.</p> <p>Sign up</p> <p>Before you can make PreFab requests, you will need to create an account<sup>1</sup>. Sign up here.</p>"},{"location":"#install-prefab","title":"Install PreFab","text":"<p>Before making your first prediction, follow the steps below to install the PreFab Python package.</p>"},{"location":"#from-pypi","title":"From PyPI","text":"<p>You can easily install PreFab using pip, which is the Python package installer. This method is suitable for most users.</p> <pre><code>pip install prefab\n</code></pre>"},{"location":"#from-github","title":"From GitHub","text":"<p>For those who wish to make changes to the source code for their own development purposes, PreFab can also be installed directly from GitHub.</p> <pre><code>git clone https://github.com/PreFab-Photonics/PreFab.git\npip install -e prefab\n</code></pre>"},{"location":"#authenticate-prefab-token","title":"Authenticate PreFab token","text":"<p>To link your PreFab account to the API, you will need to create an authentication token. You can do this by running the following command in your terminal. This will open a browser window where you can log in and generate a token.</p> <pre><code>python3 -m prefab setup\n</code></pre>"},{"location":"#prefabricate-your-designs","title":"PreFab<sub>ricate</sub> your designs","text":"<p>See the following guides to get started with making your first predictions and corrections of fabrication-induced variations with PreFab:</p> <ol> <li>Making a prediction</li> <li>Making a correction</li> </ol> <p>Performance and usage</p> <p>PreFab models are served via a serverless cloud platform. Please note:</p> <ul> <li>\ud83d\udc22 CPU inference may result in slower performance. Future updates will introduce GPU inference.</li> <li>\ud83e\udd76 The first prediction may take longer due to cold start server loading. Subsequent predictions will be faster.</li> <li>\ud83d\ude0a Be considerate of usage. Start small and limit usage during the initial stages. Thank you!</li> </ul>"},{"location":"#your-thoughts-are-valuable","title":"Your thoughts are valuable","text":"<p>PreFab is a new design tool, still in its early days, that we hope will become useful to the photonics community. We are eager to hear about your experiences with PreFab. Please share your thoughts with us and any issues you may have on GitHub.</p> <p>Happy designing  </p> <ol> <li> <p>For more information, visit our Privacy Policy and Terms of Service.  \u21a9</p> </li> </ol>"},{"location":"models/","title":"Models","text":""},{"location":"models/#overview","title":"Overview","text":"<p>PreFab accommodates unique predictor and corrector models for each photonic foundry, regularly updated based on recent fabrication data.</p> Foundry Process Latest Version Latest Dataset Model Name Model Tag ANT NanoSOI ANF0 (Jan 1 2024) d8 (Jan 1 2024) ANT_NanoSOI ANF0-d8 ANT NanoSOI ANF1 (May 6 2024) d8 (Jan 1 2024) ANT_NanoSOI ANF1-d8 ANT NanoSOI ANF1 (May 6 2024) d9 (Feb 6 2024) ANT_NanoSOI ANF1-d9 ANT NanoSOI ANF1 (May 6 2024) d10 (Jun 8 2024) ANT_NanoSOI ANF1-d10 ANT SiN ANF1 (May 6 2024) d1 (Jan 31 2024) ANT_SiN ANF1-d1 Generic DUV-SOI ANF1 (May 6 2024) d0 (Jul 30 2024) generic_DUV_SOI ANF1-d0 <p>New models and foundries are to be regularly added. Usage may change. For additional foundry and process models, feel free to contact us.</p>"},{"location":"blog/PreFab-v1.1.0/","title":"PreFab v1.1.0","text":"<pre><code>import prefab as pf\n\ntarget = pf.shapes.target(width=500, arm_width=60)\ntarget.plot()\n\ngrating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=10)\ngrating.plot()\n\nradial_grating = pf.shapes.radial_grating(width=500, num_gratings=10)\nradial_grating.plot()\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <pre><code>import time\n\nimport prefab as pf\n\ngrating = pf.shapes.grating(height=500, pitch=120, duty_cycle=0.5, num_gratings=200)\n\n# Timing the CPU correction\nstart_time = time.time()\ngrating_c_cpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=False)\ncpu_duration = time.time() - start_time\nprint(f\"CPU correction time: {cpu_duration:.2f} seconds\")\n\n# Timing the first GPU correction (cold start)\nstart_time = time.time()\ngrating_c_gpu = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True)\ngpu_duration = time.time() - start_time\nprint(f\"Cold GPU correction time: {gpu_duration:.2f} seconds\")\n\n# Timing the second GPU correction (hot start)\nstart_time = time.time()\ngrating_c_gpu2 = grating.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], gpu=True)\ngpu_duration2 = time.time() - start_time\nprint(f\"Hot GPU correction time: {gpu_duration2:.2f} seconds\")\n</code></pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:17&lt;00:00,  5.75%/s]\n</code>\n</pre> <pre>\n<code>CPU correction time: 17.68 seconds\n</code>\n</pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:08&lt;00:00, 12.39%/s]\n</code>\n</pre> <pre>\n<code>Cold GPU correction time: 27.42 seconds\n</code>\n</pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 44.18%/s]</code>\n</pre> <pre>\n<code>Hot GPU correction time: 2.47 seconds\n</code>\n</pre> <pre>\n<code>\n</code>\n</pre> <pre><code>import prefab as pf\n\nstar = pf.shapes.star(width=500, num_points=4)\nstar.plot()\n\nstar.check_feature_size(min_feature_size=30, strel=\"disk\")\nstar_e = star.enforce_feature_size(min_feature_size=30, strel=\"disk\")\nstar_e.plot()\n</code></pre> <pre>\n<code>Feature size check with minimum size 30 using 'disk' structuring element resulted in a Hamming distance of: 702\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <pre><code>import prefab as pf\n\ntarget = pf.shapes.target(width=1000, arm_width=200)\ntarget_p = target.predict(model=pf.models[\"ANT_SiN_ANF1_d1\"], binarize=True)\ntarget_p.plot()\n\ntarget_p_3d = target_p.to_3d(thickness_nm=400)  # visualizer to come soon\ntarget_p.to_stl(thickness_nm=400)  # this will create a 3D STL file you can inspect\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:04&lt;00:00, 22.84%/s]\n</code>\n</pre> <pre>\n<code>Saved Device to 'prefab_device.stl'\n</code>\n</pre> <pre><code>import gdsfactory as gf\nimport prefab as pf\n\ncomponent = gf.components.triangle(x=1, xtop=0, y=2, ybot=0, layer=\"WG\")\ncomponent.plot()\ndevice = pf.read.from_gdsfactory(component)\n\ndevice_c = device.correct(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True)\ncomponent_c = device_c.to_gdsfactory()\ncomponent_c.plot()\n</code></pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 46.44%/s]\n</code>\n</pre> <p>This second example shows how to read a Tidy3D simulation, correct the structure using PreFab, and then send it back to a Tidy3D simulation.</p> <pre><code>import prefab as pf\nimport tidy3d as td\n\nfreq0 = td.C_0 / 0.75\narm1 = td.Structure(\n    geometry=td.Box(center=(0, 0, 0), size=(0.1, 0.75, 0.22)),\n    medium=td.Medium(permittivity=2.0),\n)\narm2 = td.Structure(\n    geometry=td.Box(center=(0, 0, 0), size=(0.75, 0.1, 0.22)),\n    medium=td.Medium(permittivity=2.0),\n)\nsource = td.PointDipole(\n    center=(-0.75, 0, 0),\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=freq0 / 10.0),\n    polarization=\"Ey\",\n)\nmonitor = td.FieldMonitor(\n    size=(td.inf, td.inf, 0),\n    freqs=[freq0],\n    name=\"fields\",\n    colocate=True,\n)\nsim = td.Simulation(\n    size=(2, 2, 3),\n    grid_spec=td.GridSpec.auto(min_steps_per_wvl=100),\n    structures=[arm1, arm2],\n    sources=[source],\n    monitors=[monitor],\n    run_time=120 / freq0,\n)\n\nsim.plot_eps(z=0)\n\ndevice = pf.read.from_tidy3d(tidy3d_sim=sim, eps_threshold=1.5, z=0)\ndevice.plot()\n\ndevice_p = device.predict(model=pf.models[\"ANT_NanoSOI_ANF1_d10\"], binarize=True)\nstructure_p = device_p.to_tidy3d(eps0=2.0, thickness=1.5)\n\nsim_p = sim.updated_copy(structures=[structure_p])\nsim_p.plot_eps(z=0)\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:10&lt;00:00,  9.26%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: title={'center': 'cross section at z=0.00'}, xlabel='x', ylabel='y'&gt;</code>\n</pre>"},{"location":"blog/PreFab-v1.1.0/#prefab-v110","title":"PreFab v1.1.0","text":"<p>PreFab v1.1.0 is now available! Install it via PyPI with the following command:</p> <pre><code>pip install --upgrade prefab\n</code></pre> <p>PreFab is a Python library designed to predict and correct nanofabrication variations in integrated photonic devices using advanced computer vision models. It helps enhance fabrication awareness and boosts efficiency in the design, fabrication, and testing of photonic circuits.</p>"},{"location":"blog/PreFab-v1.1.0/#whats-new-with-us","title":"What's new with us","text":"<p>PreFab is a new startup originating from McGill University in Montreal, Canada. As we continue to grow, we are eager to learn about your needs and how we can enhance our platform. Our team is small, so we appreciate your patience as we work on these improvements. Reach out to us at hi@prefabphotonics.com to work together.</p> <ul> <li> <p>We have launched a new LinkedIn page here where we will announce new features and updates. Follow us to stay informed.</p> </li> <li> <p>We've updated our logo to be less busy while retaining its original charm and essence. We hope you like the new design!</p> </li> </ul> <p></p>"},{"location":"blog/PreFab-v1.1.0/#features","title":"Features","text":"<p>This release brings a host of new features and enhancements to elevate your experience with PreFab. While our core functionality of predicting and correcting nanofabrication variations remains unchanged, we've added several valuable tools for working with nanostructure geometries.</p>"},{"location":"blog/PreFab-v1.1.0/#shapes","title":"Shapes!","text":"<p>While <code>read.from_gds</code> is used to import your GDS cells, the new <code>shapes</code> module allows you to create basic nanostructure devices directly. This feature is not only beneficial for our internal testing but also provides a convenient way for you to test PreFab models on simple geometries. Below are some examples.</p>"},{"location":"blog/PreFab-v1.1.0/#gpu-acceleration","title":"GPU acceleration","text":"<p>We've introduced GPU acceleration to the backend of PreFab by specifying <code>gpu=True</code> in <code>Device.predict</code> and <code>Device.correct</code>. This enhancement should speed up predictions for larger devices. As PreFab is a free service, CPU inference remains the default to keep the service readily available (\"hot\") for users. For now, the GPU will be in a \"cold\" state, requiring additional time to start up. Consequently, the first GPU prediction will be slower due to this overhead. We kindly ask that you use the GPU feature modestly (scouts' honor).</p>"},{"location":"blog/PreFab-v1.1.0/#minimum-feature-size","title":"Minimum feature size","text":"<p>We've added tools to check and enforce minimum feature sizes of devices you are working with. The <code>Device.check_feature_size</code> and <code>Device.enforce_feature_size</code> methods help ensure your designs meet sizing requirements. While these tools are not full design rule checking (DRC) solutions, we believe they can be useful early in the design process.</p>"},{"location":"blog/PreFab-v1.1.0/#3d-structures","title":"3D structures","text":"<p>We have introduced the <code>Device.to_3d</code> and <code>Device.to_stl</code> methods to convert your 2D device structures into 3D arrays or STL files. These features are particularly useful for simulating processes with angled sidewalls. For more details on working with angled sidewalls, refer to this notebook.</p> <p>The <code>Device.plot</code> method displays the upper and lower edges of the sidewall-angled device structure. These two new methods use the edges as boundaries for the 3D extrusion.</p>"},{"location":"blog/PreFab-v1.1.0/#3rd-party-libraries","title":"3rd-party libraries","text":"<p>PreFab should seamlessly fit into your existing design flow. As such, we're adding tools to read and write from/to common libraries such as Tidy3D and gdsfactory.</p> <p>This first example shows how to read a gdsfactory component, correct it using PreFab, and then convert it back to a gdsfactory component.</p>"},{"location":"blog/PreFab-v1.1.0/#whats-next","title":"What's next","text":"<p>We're excited about the future of PreFab and how we can help you gain more control over your nanofabrication process. Here are our key focus areas for the upcoming months:</p> <ul> <li>Performance Enhancements: We are implementing several improvements to accelerate predictions, particularly for larger devices.</li> <li>Expanding Model Library: We are adding more models to our platform. If you have a specific nanofabrication process in mind, please reach out to us!</li> <li>Innovative Usage Methods: We have exciting ideas to make PreFab even more powerful, particularly within the design optimization process. Look out for more updates on this front.</li> <li>Code Quality: We are working on improving the code quality of PreFab to make it more robust and easier to maintain. This will lay the foundation for future development and collaboration.</li> <li>Community Engagement: We value your input and are eager to hear your ideas and suggestions. Please reach out to us at support@prefabphotonics.com with your feedback.</li> </ul> <p>Thank you for your support, and happy designing!</p>"},{"location":"examples/1_prediction/","title":"Making a prediction","text":"<p>This notebook offers an interactive tutorial on using PreFab to predict the fabrication result of a 500 nm-wide target nanostructure on a silicon-on-insulator (SOI) e-beam lithography process. This tutorial is structured as follows:</p> <ol> <li>Preparing a test device for prediction</li> <li>Executing a prediction</li> <li>Analyzing the prediction and uncertainty</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import prefab as pf\n</code></pre> <p>The first step involves preparing a device for prediction. <code>Device</code> is the base class that represents photonic design geometries in PreFab and can be instantiated by loading an image or GDS layout as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use a small target structure, but feel free to explore other structures available in the <code>shapes.py</code> module, or add your own.</p> <pre><code>device = pf.shapes.target(width=500, arm_width=60)\ndevice.plot(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We proceed with the prediction of the device for a specific fabrication model. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for a library of available models.</p> <p>You can also select if you want a binarized output. The prediction model, by default, produces raw outputs, which includes \"fuzzy\" edges of the structure that may vary between different fabrication runs or even different device instances on the same chip. When binarized, the prediction model outputs the most probable fabrication outcome (i.e., a threshold of 50%). Post-prediction binarization is also an option, as we'll show here.</p> <p>&gt; Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 43.12%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>Comparing the (binary) prediction with the nominal device, we can observe erosion (or corner rounding, or over-etching) in the 60 nm-wide arms and convex corners of the target geometry. We also see dilation (or under-etching) for the concave corners in the center, as well as the complete filling of the center opening.</p> <pre><code>prediction_bin.plot_compare(ref_device=device, show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>To evaluate the quality of the prediction quantitatively, PreFab provides a function to compute the Intersection over Union (IoU) between the prediction and the nominal device. This metric measures the overlap between the two geometries, where 1.0 indicates a perfect match and 0.0 indicates no overlap.</p> <pre><code>print(\n    f\"Prediction IoU: {pf.compare.intersection_over_union(device, prediction_bin):.2f}\"\n)\n</code></pre> <pre>\n<code>Prediction IoU: 0.83\n</code>\n</pre> <p>83% is not great, but the feature size was demanding. Try other values for <code>arm_width</code> and see how it affects the results.</p> <p>We can further visualize and understand the prediction by highlighting the \"fuzzy\" edge regions. This is a measure of the uncertainty of the prediction model due to stochastic variance in the fabrication process and the modelling process. From device-to-device, run-to-run, the device edge may lie anywhere in this uncertainty region. Although PreFab cannot correct for uncertainty, visualizing it is valuable in identifying features with high variance.</p> <pre><code>prediction.plot_uncertainty(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>And that's it! See the next example to learn how to restore this nanostructure using PreFab's correction capabilities.</p>"},{"location":"examples/1_prediction/#making-a-prediction","title":"Making a prediction","text":""},{"location":"examples/1_prediction/#introduction","title":"Introduction","text":""},{"location":"examples/1_prediction/#loading-a-device","title":"Loading a device","text":""},{"location":"examples/1_prediction/#predicting-a-device","title":"Predicting a device","text":""},{"location":"examples/1_prediction/#analyzing-a-prediction","title":"Analyzing a prediction","text":""},{"location":"examples/2_correction/","title":"Making a correction","text":"<p>This notebook offers an interactive tutorial on using PreFab to correct the fabrication result of the same 500 nm-wide target nanostructure used in the previous prediction example. This tutorial is structured as follows:</p> <ol> <li>Preparing a test device for correction</li> <li>Executing a correction</li> <li>Making a prediction of the correction</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import prefab as pf\n</code></pre> <p>The first step involves preparing a device for correction. <code>Device</code> is the base class that represents photonic design geometries in PreFab and can be instantiated by loading an image or GDS layout as an ndarray with binary pixel values: 0 or 1. In this tutorial, we'll use a small target structure, but feel free to explore other structures available in the <code>shapes.py</code> module, or add your own.</p> <pre><code>device = pf.shapes.target(width=500, arm_width=60)\ndevice.plot(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We proceed with the correction of the device for a specific fabrication model. Each model is labeled by its fabrication facility and process name, model version, and dataset version. Refer to <code>docs/models.md</code> for a library of available models.</p> <p>&gt; Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\"\ncorrection = device.correct(model=pf.models[MODEL_NAME])\ncorrection.plot(show_buffer=False)\n</code></pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 83.13%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>The corrector compensates for expected fabrication errors by adjusting the design. It adds silicon in places where it predicts erosion and removes silicon where it predicts dilation.</p> <pre><code>correction.plot_compare(ref_device=device, show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We then predict the nanofabrication outcome for the corrected target structure by using the prediction model again.</p> <p>In the corrected design, the corners are expected to be sharper and the middle opening is better resolved compared to the nominal design. Additionally, the Intersection over Union score is improved from 83% to 98%! This means that the corrected design will more closely match the intended design, leading to better fabrication outcomes and better chips.</p> <pre><code>outcome = correction.predict(model=pf.models[MODEL_NAME])\noutcome_bin = outcome.binarize()\n\noutcome.plot(show_buffer=False)\noutcome_bin.plot(show_buffer=False)\noutcome_bin.plot_compare(ref_device=device, show_buffer=False)\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 41.95%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <pre><code>print(f\"Corrected IoU: {pf.compare.intersection_over_union(device, outcome_bin):.2f}\")\n</code></pre> <pre>\n<code>Corrected IoU: 0.98\n</code>\n</pre> <p>While it may not always be possible to fully restore the original design to 100%, achieving this is our goal. We encourage you to stay up-to-date with our latest models, as we are continually striving to improve.</p>"},{"location":"examples/2_correction/#making-a-correction","title":"Making a correction","text":""},{"location":"examples/2_correction/#introduction","title":"Introduction","text":""},{"location":"examples/2_correction/#loading-a-device","title":"Loading a device","text":""},{"location":"examples/2_correction/#correcting-a-device","title":"Correcting a device","text":""},{"location":"examples/2_correction/#making-a-prediction-of-the-correction","title":"Making a prediction of the correction","text":""},{"location":"examples/3_sidewall_angle/","title":"Working with sidewall angles","text":"<p>This notebook uses PreFab to predict and correct the fabrication result of a 400 nm-wide ring nanostructure on a silicon nitride (SiN) e-beam lithography process that has angled sidewalls. This tutorial is structured as follows:</p> <ol> <li>Preparing a test device for prediction</li> <li>Executing a prediction</li> <li>Analyzing the prediction and uncertainty</li> <li>Correcting the device and discussion of sidewall angles</li> </ol> <p>To begin, we need to import the necessary libraries:</p> <pre><code>import matplotlib.pyplot as plt\nimport prefab as pf\n</code></pre> <p>In this tutorial, we'll use a small ring structure, but feel free to explore other structures available in the <code>shapes.py</code> module, or load your own from a GDS file.</p> <pre><code>device = pf.shapes.ring(width=400, border_width=100)\ndevice.plot(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>The prediction process is similar to previous notebook examples, but we'll use a model trained on SiN structures with angled sidewalls. This model outputs three segments: core (yellow), sidewall of the core (green), and cladding (purple), unlike the previous examples' models which had only core and cladding (indicating a vertical sidewall).</p> <p>&gt; Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_SiN_ANF1_d1\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:06&lt;00:00, 16.13%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>The model outputs an NxMx2 array, where the third dimension represents the top and bottom edges of the structure. We can visualize these edges separately using the <code>level</code> parameter.</p> <pre><code>prediction.plot(level=0, show_buffer=False)\nprediction.plot(level=1, show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We can overlay the contour of the nominal device on the prediction to visualize the differences between the nominal and predicted geometries. This comparison reveals significant erosion at the top level or edge, and shows that the outer sidewall is wider than the inner sidewall, indicating a non-uniform, feature-dependent sidewall angle.</p> <pre><code>fig, ax = plt.subplots(1, 1, figsize=(10, 5))\nprediction_bin.plot(show_buffer=False, ax=ax)\ndevice.plot_contour(show_buffer=False, ax=ax)\nplt.show()\n</code></pre> <p>Likewise, each edge carries its own level of uncertainty. We are still investigating the relationship between edge uncertainty and sidewall angle, and how they vary from device to device and fabrication run to run. The less these uncertainties overlap with the optical signal, the more robust the device will be to fabrication variations.</p> <pre><code>prediction.plot_uncertainty(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>The sidewall angle is a result of the etching process and cannot be corrected through lithography adjustments. However, we can compensate for the sidewall angle by ensuring the half-width of the sidewall region matches the nominal width. By overlaying the contour of the nominal device on the corrected outcome, we can see that the corrector model has successfully compensated for the sidewall angle.</p> <p>This method helps maintain a consistent effective volume and index profile, minimizing performance degradation. Research is ongoing to verify different sidewall-angle compensation strategies. Other factors to consider include the height of the core region and the linearity of the sidewall.</p> <pre><code>MODEL_NAME = \"ANT_SiN_ANF1_d1\"\ncorrection = device.correct(model=pf.models[MODEL_NAME])\noutcome = correction.predict(model=pf.models[MODEL_NAME])\noutcome_bin = outcome.binarize()\n\ncorrection.plot(show_buffer=False)\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 5))\noutcome_bin.plot(show_buffer=False, ax=ax)\ndevice.plot_contour(show_buffer=False, ax=ax)\nplt.show()\n</code></pre> <pre>\n<code>Correction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:01&lt;00:00, 78.78%/s]\nPrediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 39.85%/s]\n</code>\n</pre> <p>Feel free to try different structures and settings to see how they affect your designs. Thanks for following along!</p>"},{"location":"examples/3_sidewall_angle/#working-with-sidewall-angles","title":"Working with sidewall angles","text":""},{"location":"examples/3_sidewall_angle/#introduction","title":"Introduction","text":""},{"location":"examples/3_sidewall_angle/#loading-a-device","title":"Loading a device","text":""},{"location":"examples/3_sidewall_angle/#predicting-a-device","title":"Predicting a device","text":""},{"location":"examples/3_sidewall_angle/#analyzing-a-prediction","title":"Analyzing a prediction","text":""},{"location":"examples/3_sidewall_angle/#correction","title":"Correction","text":""},{"location":"examples/4_SEM_generation/","title":"SEM generation","text":"<pre><code>import prefab as pf\n</code></pre> <p>In this tutorial, we'll use an L-grating structure, but feel free to explore other structures available in the <code>shapes</code> module, or load your own from a GDS file.</p> <pre><code>device = pf.shapes.L_grating(height=500, pitch=90)\ndevice.plot(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We'll run our prediction just like we did in the previous tutorial. Note how the small gaps between the L-grating arms are highly uncertain in the raw prediction and get partially filled in by the binarization step. As expected, there is also significant rounding at the corners of the L-grating arms.</p> <p>&gt; Note: Initial prediction/correction may take longer due to server startup and model loading. Subsequent predictions should be quicker.</p> <pre><code>MODEL_NAME = \"ANT_NanoSOI_ANF1_d10\"\nprediction = device.predict(model=pf.models[MODEL_NAME])\nprediction_bin = prediction.binarize()\n\nprediction.plot(show_buffer=False)\nprediction_bin.plot(show_buffer=False)\n</code></pre> <pre>\n<code>Prediction: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 44.07%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>We are exploring a feature that uses varying threshold levels around the edges of the prediction. Although this method is not yet fully validated, it shows promise in producing more realistic images that display bumps and roughness along the sidewalls of the fabricated devices. While this is primarily for aesthetic purposes in this tutorial, we believe it will be useful in assessing the robustness to edge defects in the fabrication process. This is an active area of research, and we welcome any feedback and suggestions.</p> <pre><code>prediction_bin_rng = prediction.binarize_monte_carlo(\n    threshold_noise_std=2, threshold_blur_std=10\n)\nprediction_bin_rng.plot(show_buffer=False)\n</code></pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>Lastly, we can generate an SEM-like image of the randomly thresholded prediction using the <code>semulate</code> method and specifying the artificial nanofabrication model for the process we used to create the prediction.</p> <pre><code>sem = prediction_bin_rng.semulate(pf.models[\"ANT_NanoSOI_ANF1_d10\"])\nsem.plot(show_buffer=False, cmap=\"gray\")\n</code></pre> <pre>\n<code>SEMulate: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:02&lt;00:00, 37.29%/s]\n</code>\n</pre> <pre>\n<code>&lt;Axes: xlabel='x (nm)', ylabel='y (nm)'&gt;</code>\n</pre> <p>Of course, SEM styling is influenced by various factors, including the fabrication process, the specific SEM equipment used, and the expertise of the operator. While these generated images are not intended to replace actual SEM imaging, they demonstrate a compelling alternative application of our computer vision models.</p>"},{"location":"examples/4_SEM_generation/#generating-sem-like-images","title":"Generating SEM-Like Images","text":""},{"location":"examples/4_SEM_generation/#introduction","title":"Introduction","text":"<p>This notebook shows how our computer vision models can be used to generate (SEMulate) SEM-like images of the predicted device geometries. Unlike the other notebook examples in our docs, there is no utility here, but it is a fun application of our computer vision models. We'll go through the following steps:</p> <ol> <li>Preparing a test device for prediction</li> <li>Executing a prediction</li> <li>Generating an SEM-like image</li> </ol> <p>To begin, we need to import the necessary libraries:</p>"},{"location":"examples/4_SEM_generation/#loading-a-device","title":"Loading a device","text":""},{"location":"examples/4_SEM_generation/#predicting-a-device","title":"Predicting a device","text":""},{"location":"examples/4_SEM_generation/#generating-an-sem-like-image","title":"Generating an SEM-like image","text":""},{"location":"reference/compare/","title":"Compare","text":"<p>Provides functions to measure the similarity between devices.</p>"},{"location":"reference/compare/#prefab.compare.dice_coefficient","title":"<code>dice_coefficient(device_a, device_b)</code>","text":"<p>Calculates the Dice coefficient between two binary devices. A value closer to 1 indicates more similarity. The Dice coefficient is calculated as twice the number of pixels in common divided by the total number of pixels in the two devices.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (binarized).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Dice coefficient between two devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def dice_coefficient(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Dice coefficient between two binary devices. A value closer to 1\n    indicates more similarity. The Dice coefficient is calculated as twice the number of\n    pixels in common divided by the total number of pixels in the two devices.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (binarized).\n    device_b : Device\n        The second device (binarized).\n\n    Returns\n    -------\n    float\n        The Dice coefficient between two devices.\n    \"\"\"\n    intersection = 2.0 * np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    )\n    size_a = np.sum(device_a.device_array)\n    size_b = np.sum(device_b.device_array)\n    return intersection / (size_a + size_b)\n</code></pre>"},{"location":"reference/compare/#prefab.compare.hamming_distance","title":"<code>hamming_distance(device_a, device_b)</code>","text":"<p>Calculates the Hamming distance between two binary devices. A lower value indicates more similarity. The Hamming distance is calculated as the number of positions at which the corresponding pixels are different.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (binarized).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The Hamming distance between two devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def hamming_distance(device_a: Device, device_b: Device) -&gt; int:\n    \"\"\"\n    Calculates the Hamming distance between two binary devices. A lower value indicates\n    more similarity. The Hamming distance is calculated as the number of positions at\n    which the corresponding pixels are different.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (binarized).\n    device_b : Device\n        The second device (binarized).\n\n    Returns\n    -------\n    int\n        The Hamming distance between two devices.\n    \"\"\"\n    return np.sum(device_a.device_array != device_b.device_array)\n</code></pre>"},{"location":"reference/compare/#prefab.compare.intersection_over_union","title":"<code>intersection_over_union(device_a, device_b)</code>","text":"<p>Calculates the Intersection over Union (IoU) between two binary devices. A value closer to 1 indicates more similarity (more overlap).</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (binarized).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Intersection over Union between two devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def intersection_over_union(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculates the Intersection over Union (IoU) between two binary devices. A value\n    closer to 1 indicates more similarity (more overlap).\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (binarized).\n    device_b : Device\n        The second device (binarized).\n\n    Returns\n    -------\n    float\n        The Intersection over Union between two devices.\n    \"\"\"\n    return np.sum(\n        np.logical_and(device_a.device_array, device_b.device_array)\n    ) / np.sum(np.logical_or(device_a.device_array, device_b.device_array))\n</code></pre>"},{"location":"reference/compare/#prefab.compare.mean_squared_error","title":"<code>mean_squared_error(device_a, device_b)</code>","text":"<p>Calculate the mean squared error (MSE) between two non-binarized devices. A lower value indicates more similarity.</p> <p>Parameters:</p> Name Type Description Default <code>device_a</code> <code>Device</code> <p>The first device (non-binarized).</p> required <code>device_b</code> <code>Device</code> <p>The second device (non-binarized).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The mean squared error between two devices.</p> Source code in <code>prefab/compare.py</code> <pre><code>def mean_squared_error(device_a: Device, device_b: Device) -&gt; float:\n    \"\"\"\n    Calculate the mean squared error (MSE) between two non-binarized devices. A lower\n    value indicates more similarity.\n\n    Parameters\n    ----------\n    device_a : Device\n        The first device (non-binarized).\n    device_b : Device\n        The second device (non-binarized).\n\n    Returns\n    -------\n    float\n        The mean squared error between two devices.\n    \"\"\"\n    return np.mean((device_a.device_array - device_b.device_array) ** 2)\n</code></pre>"},{"location":"reference/device/","title":"Device","text":"<p>Provides the Device class for representing photonic devices.</p>"},{"location":"reference/device/#prefab.device.BufferSpec","title":"<code>BufferSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines the specifications for a buffer zone around a device.</p> <p>This class is used to specify the mode and thickness of a buffer zone that is added around the device geometry. The buffer zone can be used for various purposes such as providing extra space for device fabrication processes or for ensuring that the device is isolated from surrounding structures.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>dict[str, str]</code> <p>A dictionary that defines the buffer mode for each side of the device ('top', 'bottom', 'left', 'right'), where 'constant' is used for isolated structures and 'edge' is utilized for preserving the edge, such as for waveguide connections.</p> required <code>thickness</code> <code>dict[str, conint(gt=0)]</code> <p>A dictionary that defines the thickness of the buffer zone for each side of the device ('top', 'bottom', 'left', 'right'). Each value must be greater than 0.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any of the modes specified in the 'mode' dictionary are not one of the allowed values ('constant', 'edge'). Or if any of the thickness values are not greater than 0.</p> Example <pre><code>import prefab as pf\n\nbuffer_spec = pf.BufferSpec(\n    mode={\n        \"top\": \"constant\",\n        \"bottom\": \"edge\",\n        \"left\": \"constant\",\n        \"right\": \"edge\",\n    },\n    thickness={\n        \"top\": 150,\n        \"bottom\": 100,\n        \"left\": 200,\n        \"right\": 250,\n    },\n)\n</code></pre> Source code in <code>prefab/device.py</code> <pre><code>class BufferSpec(BaseModel):\n    \"\"\"\n    Defines the specifications for a buffer zone around a device.\n\n    This class is used to specify the mode and thickness of a buffer zone that is added\n    around the device geometry. The buffer zone can be used for various purposes such as\n    providing extra space for device fabrication processes or for ensuring that the\n    device is isolated from surrounding structures.\n\n    Parameters\n    ----------\n    mode : dict[str, str]\n        A dictionary that defines the buffer mode for each side of the device\n        ('top', 'bottom', 'left', 'right'), where 'constant' is used for isolated\n        structures and 'edge' is utilized for preserving the edge, such as for waveguide\n        connections.\n    thickness : dict[str, conint(gt=0)]\n        A dictionary that defines the thickness of the buffer zone for each side of the\n        device ('top', 'bottom', 'left', 'right'). Each value must be greater than 0.\n\n    Raises\n    ------\n    ValueError\n        If any of the modes specified in the 'mode' dictionary are not one of the\n        allowed values ('constant', 'edge'). Or if any of the thickness values are not\n        greater than 0.\n\n    Example\n    -------\n        import prefab as pf\n\n        buffer_spec = pf.BufferSpec(\n            mode={\n                \"top\": \"constant\",\n                \"bottom\": \"edge\",\n                \"left\": \"constant\",\n                \"right\": \"edge\",\n            },\n            thickness={\n                \"top\": 150,\n                \"bottom\": 100,\n                \"left\": 200,\n                \"right\": 250,\n            },\n        )\n    \"\"\"\n\n    mode: dict[str, str] = Field(\n        default_factory=lambda: {\n            \"top\": \"constant\",\n            \"bottom\": \"constant\",\n            \"left\": \"constant\",\n            \"right\": \"constant\",\n        }\n    )\n    thickness: dict[str, conint(gt=0)] = Field(\n        default_factory=lambda: {\n            \"top\": 128,\n            \"bottom\": 128,\n            \"left\": 128,\n            \"right\": 128,\n        }\n    )\n\n    @validator(\"mode\", pre=True)\n    def check_mode(cls, v):\n        allowed_modes = [\"constant\", \"edge\"]\n        if not all(mode in allowed_modes for mode in v.values()):\n            raise ValueError(f\"Buffer mode must be one of {allowed_modes}, got '{v}'\")\n        return v\n</code></pre>"},{"location":"reference/device/#prefab.device.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>prefab/device.py</code> <pre><code>class Device(BaseModel):\n    device_array: np.ndarray = Field(...)\n    buffer_spec: BufferSpec = Field(default_factory=BufferSpec)\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    @property\n    def shape(self) -&gt; tuple[int, int]:\n        return self.device_array.shape\n\n    def __init__(\n        self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n    ):\n        \"\"\"\n        Represents the planar geometry of a photonic device design that will have its\n        nanofabrication outcome predicted and/or corrected.\n\n        This class is designed to encapsulate the geometric representation of a photonic\n        device, facilitating operations such as padding, normalization, binarization,\n        ternarization, trimming, and blurring. These operations are useful for preparing\n        the device design for prediction or correction. Additionally, the class provides\n        methods for exporting the device representation to various formats, including\n        ndarray, image files, and GDSII files, supporting a range of analysis and\n        fabrication workflows.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            A 2D array representing the planar geometry of the device. This array\n            undergoes various transformations to predict or correct the nanofabrication\n            process.\n        buffer_spec : BufferSpec, optional\n            Defines the parameters for adding a buffer zone around the device geometry.\n            This buffer zone is needed for providing surrounding context for prediction\n            or correction and for ensuring seamless integration with the surrounding\n            circuitry. By default, a generous padding is applied to accommodate isolated\n            structures.\n\n        Attributes\n        ----------\n        shape : tuple[int, int]\n            The shape of the device array.\n\n        Raises\n        ------\n        ValueError\n            If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n            indicating an invalid device geometry.\n        \"\"\"\n        super().__init__(\n            device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n        )\n        self._initial_processing()\n\n    def __call__(self, *args, **kwargs):\n        return self.plot(*args, **kwargs)\n\n    def _initial_processing(self):\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((buffer_thickness[\"top\"], 0), (0, 0)),\n            mode=buffer_mode[\"top\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, buffer_thickness[\"bottom\"]), (0, 0)),\n            mode=buffer_mode[\"bottom\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, 0), (buffer_thickness[\"left\"], 0)),\n            mode=buffer_mode[\"left\"],\n        )\n        self.device_array = np.pad(\n            self.device_array,\n            pad_width=((0, 0), (0, buffer_thickness[\"right\"])),\n            mode=buffer_mode[\"right\"],\n        )\n\n        self.device_array = np.expand_dims(self.device_array, axis=-1)\n\n    @root_validator(pre=True)\n    def check_device_array(cls, values):\n        device_array = values.get(\"device_array\")\n        if not isinstance(device_array, np.ndarray):\n            raise ValueError(\"device_array must be a numpy ndarray.\")\n        if device_array.ndim != 2:\n            raise ValueError(\"device_array must be a 2D array.\")\n        return values\n\n    def is_binary(self) -&gt; bool:\n        \"\"\"\n        Check if the device geometry is binary.\n\n        Returns\n        -------\n        bool\n            True if the device geometry is binary, False otherwise.\n        \"\"\"\n        unique_values = np.unique(self.device_array)\n        return (\n            np.array_equal(unique_values, [0, 1])\n            or np.array_equal(unique_values, [1, 0])\n            or np.array_equal(unique_values, [0])\n            or np.array_equal(unique_values, [1])\n        )\n\n    def _encode_array(self, array):\n        image = Image.fromarray(np.uint8(array * 255))\n        buffered = io.BytesIO()\n        image.save(buffered, format=\"PNG\")\n        encoded_png = base64.b64encode(buffered.getvalue()).decode(\"utf-8\")\n        return encoded_png\n\n    def _decode_array(self, encoded_png):\n        binary_data = base64.b64decode(encoded_png)\n        image = Image.open(io.BytesIO(binary_data))\n        return np.array(image) / 255\n\n    def _predict_array(\n        self,\n        model: Model,\n        model_type: str,\n        binarize: bool,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        try:\n            with open(os.path.expanduser(\"~/.prefab.toml\")) as file:\n                content = file.readlines()\n                access_token = None\n                refresh_token = None\n                for line in content:\n                    if \"access_token\" in line:\n                        access_token = line.split(\"=\")[1].strip().strip('\"')\n                    if \"refresh_token\" in line:\n                        refresh_token = line.split(\"=\")[1].strip().strip('\"')\n                        break\n                if not access_token or not refresh_token:\n                    raise ValueError(\"Token not found in the configuration file.\")\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Could not validate user.\\n\"\n                \"Please update prefab using: pip install --upgrade prefab.\\n\"\n                \"Signup/login and generate a new token.\\n\"\n                \"See https://www.prefabphotonics.com/docs/guides/quickstart.\"\n            ) from None\n\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"X-Refresh-Token\": refresh_token,\n        }\n\n        predict_data = {\n            \"device_array\": self._encode_array(self.device_array[:, :, 0]),\n            \"model\": model.to_json(),\n            \"model_type\": model_type,\n            \"binary\": binarize,\n        }\n        json_data = json.dumps(predict_data)\n\n        endpoint_url = (\n            \"https://prefab-photonics--predict-gpu-v1.modal.run\"\n            if gpu\n            else \"https://prefab-photonics--predict-v1.modal.run\"\n        )\n\n        try:\n            with requests.post(\n                endpoint_url, data=json_data, headers=headers, stream=True\n            ) as response:\n                response.raise_for_status()\n                event_type = None\n                model_descriptions = {\n                    \"p\": \"Prediction\",\n                    \"c\": \"Correction\",\n                    \"s\": \"SEMulate\",\n                }\n                progress_bar = tqdm(\n                    total=100,\n                    desc=f\"{model_descriptions[model_type]}\",\n                    unit=\"%\",\n                    colour=\"green\",\n                    bar_format=\"{l_bar}{bar:30}{r_bar}{bar:-10b}\",\n                )\n\n                for line in response.iter_lines():\n                    if line:\n                        decoded_line = line.decode(\"utf-8\").strip()\n                        if decoded_line.startswith(\"event:\"):\n                            event_type = decoded_line.split(\":\")[1].strip()\n                        elif decoded_line.startswith(\"data:\"):\n                            try:\n                                data_content = json.loads(\n                                    decoded_line.split(\"data: \")[1]\n                                )\n                                if event_type == \"progress\":\n                                    progress = round(100 * data_content[\"progress\"])\n                                    progress_bar.update(progress - progress_bar.n)\n                                elif event_type == \"result\":\n                                    results = []\n                                    for key in sorted(data_content.keys()):\n                                        if key.startswith(\"result\"):\n                                            decoded_image = self._decode_array(\n                                                data_content[key]\n                                            )\n                                            results.append(decoded_image)\n\n                                    if results:\n                                        prediction = np.stack(results, axis=-1)\n                                        if binarize:\n                                            prediction = geometry.binarize_hard(\n                                                prediction\n                                            )\n                                        progress_bar.close()\n                                        return prediction\n                                elif event_type == \"end\":\n                                    print(\"Stream ended.\")\n                                    progress_bar.close()\n                                    break\n                                elif event_type == \"auth\":\n                                    if \"new_refresh_token\" in data_content[\"auth\"]:\n                                        prefab_file_path = os.path.expanduser(\n                                            \"~/.prefab.toml\"\n                                        )\n                                        with open(\n                                            prefab_file_path, \"w\", encoding=\"utf-8\"\n                                        ) as toml_file:\n                                            toml.dump(\n                                                {\n                                                    \"access_token\": data_content[\n                                                        \"auth\"\n                                                    ][\"new_access_token\"],\n                                                    \"refresh_token\": data_content[\n                                                        \"auth\"\n                                                    ][\"new_refresh_token\"],\n                                                },\n                                                toml_file,\n                                            )\n                                elif event_type == \"error\":\n                                    raise ValueError(f\"{data_content['error']}\")\n                            except json.JSONDecodeError:\n                                raise ValueError(\n                                    \"Failed to decode JSON:\",\n                                    decoded_line.split(\"data: \")[1],\n                                ) from None\n        except requests.RequestException as e:\n            raise RuntimeError(f\"Request failed: {e}\") from e\n\n    def predict(\n        self,\n        model: Model,\n        binarize: bool = False,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Predict the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless prediction service, which\n        uses a specified machine learning model to predict the outcome of the\n        nanofabrication process.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for prediction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the prediction\n            is tailored to specific fabrication parameters.\n        binarize : bool, optional\n            If True, the predicted device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic predictions into binary\n            geometries. Defaults to False.\n        gpu : bool, optional\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the predicted geometry.\n\n        Raises\n        ------\n        ValueError\n            If the prediction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        prediction_array = self._predict_array(\n            model=model,\n            model_type=\"p\",\n            binarize=binarize,\n            gpu=gpu,\n        )\n        return self.model_copy(update={\"device_array\": prediction_array})\n\n    def correct(\n        self,\n        model: Model,\n        binarize: bool = True,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Correct the nanofabrication outcome of the device using a specified model.\n\n        This method sends the device geometry to a serverless correction service, which\n        uses a specified machine learning model to correct the outcome of the\n        nanofabrication process. The correction aims to adjust the device geometry to\n        compensate for known fabrication errors and improve the accuracy of the final\n        device structure.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for correction, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the correction\n            is tailored to specific fabrication parameters.\n        binarize : bool, optional\n            If True, the corrected device geometry will be binarized using a threshold\n            method. This is useful for converting probabilistic corrections into binary\n            geometries. Defaults to True.\n        gpu : bool, optional\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with the corrected geometry.\n\n        Raises\n        ------\n        ValueError\n            If the correction service returns an error or if the response from the\n            service cannot be processed correctly.\n        \"\"\"\n        correction_array = self._predict_array(\n            model=model,\n            model_type=\"c\",\n            binarize=binarize,\n            gpu=gpu,\n        )\n        return self.model_copy(update={\"device_array\": correction_array})\n\n    def semulate(\n        self,\n        model: Model,\n        gpu: bool = False,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Simulate the appearance of the device as if viewed under a scanning electron\n        microscope (SEM).\n\n        This method applies a specified machine learning model to transform the device\n        geometry into a style that resembles an SEM image. This can be useful for\n        visualizing how the device might appear under an SEM, which is often used for\n        inspecting the surface and composition of materials at high magnification.\n\n        Parameters\n        ----------\n        model : Model\n            The model to use for SEMulation, representing a specific fabrication process\n            and dataset. This model encapsulates details about the fabrication foundry,\n            process, material, technology, thickness, and sidewall presence, as defined\n            in `models.py`. Each model is associated with a version and dataset that\n            detail its creation and the data it was trained on, ensuring the SEMulation\n            is tailored to specific fabrication parameters.\n        gpu : bool, optional\n            If True, the prediction will be performed on a GPU. Defaults to False.\n            Note: The GPU option has more overhead and will take longer for small\n            devices, but will be faster for larger devices.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device class with its geometry transformed to simulate\n            an SEM image style.\n        \"\"\"\n        semulated_array = self._predict_array(\n            model=model,\n            model_type=\"s\",\n            binarize=False,\n            gpu=gpu,\n        )\n        semulated_array += np.random.normal(0, 0.03, semulated_array.shape)\n        return self.model_copy(update={\"device_array\": semulated_array})\n\n    def to_ndarray(self) -&gt; np.ndarray:\n        \"\"\"\n        Converts the device geometry to an ndarray.\n\n        This method applies the buffer specifications to crop the device array if\n        necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n        resulting ndarray representing the device geometry.\n\n        Returns\n        -------\n        np.ndarray\n            The ndarray representation of the device geometry, with any applied buffer\n            cropping.\n        \"\"\"\n        device_array = np.copy(self.device_array)\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_mode = self.buffer_spec.mode\n\n        crop_top = buffer_thickness[\"top\"] if buffer_mode[\"top\"] == \"edge\" else 0\n        crop_bottom = (\n            buffer_thickness[\"bottom\"] if buffer_mode[\"bottom\"] == \"edge\" else 0\n        )\n        crop_left = buffer_thickness[\"left\"] if buffer_mode[\"left\"] == \"edge\" else 0\n        crop_right = buffer_thickness[\"right\"] if buffer_mode[\"right\"] == \"edge\" else 0\n\n        ndarray = device_array[\n            crop_top : device_array.shape[0] - crop_bottom,\n            crop_left : device_array.shape[1] - crop_right,\n        ]\n        return np.squeeze(ndarray)\n\n    def to_img(self, img_path: str = \"prefab_device.png\"):\n        \"\"\"\n        Exports the device geometry as an image file.\n\n        This method converts the device geometry to an ndarray using `to_ndarray`,\n        scales the values to the range [0, 255] for image representation, and saves the\n        result as an image file.\n\n        Parameters\n        ----------\n        img_path : str, optional\n            The path where the image file will be saved. If not specified, the image is\n            saved as \"prefab_device.png\" in the current directory.\n        \"\"\"\n        cv2.imwrite(img_path, 255 * self.flatten().to_ndarray())\n        print(f\"Saved Device to '{img_path}'\")\n\n    def to_gds(\n        self,\n        gds_path: str = \"prefab_device.gds\",\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n    ):\n        \"\"\"\n        Exports the device geometry as a GDSII file.\n\n        This method converts the device geometry into a format suitable for GDSII files.\n        The conversion involves contour approximation to simplify the geometry while\n        preserving essential features.\n\n        Parameters\n        ----------\n        gds_path : str, optional\n            The path where the GDSII file will be saved. If not specified, the file is\n            saved as \"prefab_device.gds\" in the current directory.\n        cell_name : str, optional\n            The name of the cell within the GDSII file. If not specified, defaults to\n            \"prefab_device\".\n        gds_layer : tuple[int, int], optional\n            The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n        contour_approx_mode : int, optional\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n        \"\"\"\n        gdstk_cell = self.flatten()._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n        )\n        print(f\"Saving GDS to '{gds_path}'...\")\n        gdstk_library = gdstk.Library()\n        gdstk_library.add(gdstk_cell)\n        gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n\n    def to_gdstk(\n        self,\n        cell_name: str = \"prefab_device\",\n        gds_layer: tuple[int, int] = (1, 0),\n        contour_approx_mode: int = 2,\n    ):\n        \"\"\"\n        Converts the device geometry to a GDSTK cell object.\n\n        This method prepares the device geometry for GDSII file export by converting it\n        into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n        GDSII layout files. The conversion involves contour approximation to simplify\n        the geometry while preserving essential features.\n\n        Parameters\n        ----------\n        cell_name : str, optional\n            The name of the cell to be created. Defaults to \"prefab_device\".\n        gds_layer : tuple[int, int], optional\n            The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n        contour_approx_mode : int, optional\n            The mode of contour approximation used during the conversion. Defaults to 2,\n            which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n            horizontal, vertical, and diagonal segments and leaves only their endpoints.\n\n        Returns\n        -------\n        gdstk.Cell\n            The GDSTK cell object representing the device geometry.\n        \"\"\"\n        print(f\"Creating cell '{cell_name}'...\")\n        gdstk_cell = self.flatten()._device_to_gdstk(\n            cell_name=cell_name,\n            gds_layer=gds_layer,\n            contour_approx_mode=contour_approx_mode,\n        )\n        return gdstk_cell\n\n    def _device_to_gdstk(\n        self,\n        cell_name: str,\n        gds_layer: tuple[int, int],\n        contour_approx_mode: int,\n    ) -&gt; gdstk.Cell:\n        approx_mode_mapping = {\n            1: cv2.CHAIN_APPROX_NONE,\n            2: cv2.CHAIN_APPROX_SIMPLE,\n            3: cv2.CHAIN_APPROX_TC89_L1,\n            4: cv2.CHAIN_APPROX_TC89_KCOS,\n        }\n\n        contours, hierarchy = cv2.findContours(\n            np.flipud(self.to_ndarray()).astype(np.uint8),\n            cv2.RETR_TREE,\n            approx_mode_mapping[contour_approx_mode],\n        )\n\n        hierarchy_polygons = {}\n        for idx, contour in enumerate(contours):\n            level = 0\n            current_idx = idx\n            while hierarchy[0][current_idx][3] != -1:\n                level += 1\n                current_idx = hierarchy[0][current_idx][3]\n\n            if len(contour) &gt; 2:\n                contour = contour / 1000\n                points = [tuple(point) for point in contour.squeeze().tolist()]\n                if level not in hierarchy_polygons:\n                    hierarchy_polygons[level] = []\n                hierarchy_polygons[level].append(points)\n\n        cell = gdstk.Cell(cell_name)\n        processed_polygons = []\n        for level in sorted(hierarchy_polygons.keys()):\n            operation = \"or\" if level % 2 == 0 else \"xor\"\n            polygons_to_process = hierarchy_polygons[level]\n\n            if polygons_to_process:\n                processed_polygons = gdstk.boolean(\n                    polygons_to_process,\n                    processed_polygons,\n                    operation,\n                    layer=gds_layer[0],\n                    datatype=gds_layer[1],\n                )\n        for polygon in processed_polygons:\n            cell.add(polygon)\n\n        return cell\n\n    def to_gdsfactory(self) -&gt; \"gf.Component\":  # noqa: F821\n        \"\"\"\n        Convert the device geometry to a gdsfactory Component.\n\n        Returns\n        -------\n        gf.Component\n            A gdsfactory Component object representing the device geometry.\n\n        Raises\n        ------\n        ImportError\n            If the gdsfactory package is not installed.\n        \"\"\"\n        try:\n            import gdsfactory as gf\n        except ImportError:\n            raise ImportError(\n                \"The gdsfactory package is required to use this function; \"\n                \"try `pip install gdsfactory`.\"\n            ) from None\n\n        device_array = np.rot90(self.to_ndarray(), k=-1)\n        return gf.read.from_np(device_array, nm_per_pixel=1)\n\n    def to_tidy3d(\n        self,\n        eps0: float,\n        thickness: float,\n    ) -&gt; \"td.Structure\":  # noqa: F821\n        \"\"\"\n        Convert the device geometry to a Tidy3D Structure.\n\n        Parameters\n        ----------\n        eps0 : float\n            The permittivity value to assign to the device array.\n        thickness : float\n            The thickness of the device in the z-direction.\n\n        Returns\n        -------\n        td.Structure\n            A Tidy3D Structure object representing the device geometry.\n\n        Raises\n        ------\n        ImportError\n            If the tidy3d package is not installed.\n        \"\"\"\n        try:\n            from tidy3d import Box, CustomMedium, SpatialDataArray, Structure, inf\n        except ImportError:\n            raise ImportError(\n                \"The tidy3d package is required to use this function; \"\n                \"try `pip install tidy3d`.\"\n            ) from None\n\n        X = np.linspace(-self.shape[1] / 2000, self.shape[1] / 2000, self.shape[1])\n        Y = np.linspace(-self.shape[0] / 2000, self.shape[0] / 2000, self.shape[0])\n        Z = np.array([0])\n\n        device_array = np.rot90(np.fliplr(self.device_array), k=1)\n        eps_array = np.where(device_array &gt;= 1.0, eps0, device_array)\n        eps_array = np.where(eps_array &lt; 1.0, 1.0, eps_array)\n        eps_dataset = SpatialDataArray(eps_array, coords=dict(x=X, y=Y, z=Z))\n        medium = CustomMedium.from_eps_raw(eps_dataset)\n        return Structure(\n            geometry=Box(center=(0, 0, 0), size=(inf, inf, thickness)), medium=medium\n        )\n\n    def to_3d(self, thickness_nm: int) -&gt; np.ndarray:\n        \"\"\"\n        Convert the 2D device geometry into a 3D representation.\n\n        This method creates a 3D array by interpolating between the bottom and top\n        layers of the device geometry. The interpolation is linear.\n\n        Parameters\n        ----------\n        thickness_nm : int\n            The thickness of the 3D representation in nanometers.\n\n        Returns\n        -------\n        np.ndarray\n            A 3D narray representing the device geometry with the specified thickness.\n        \"\"\"\n        bottom_layer = self.device_array[:, :, 0]\n        top_layer = self.device_array[:, :, -1]\n        dt_bottom = distance_transform_edt(bottom_layer) - distance_transform_edt(\n            1 - bottom_layer\n        )\n        dt_top = distance_transform_edt(top_layer) - distance_transform_edt(\n            1 - top_layer\n        )\n        weights = np.linspace(0, 1, thickness_nm)\n        layered_array = np.zeros(\n            (bottom_layer.shape[0], bottom_layer.shape[1], thickness_nm)\n        )\n        for i, w in enumerate(weights):\n            dt_interp = (1 - w) * dt_bottom + w * dt_top\n            layered_array[:, :, i] = dt_interp &gt;= 0\n        return layered_array\n\n    def to_stl(self, thickness_nm: int, filename: str = \"prefab_device.stl\"):\n        \"\"\"\n        Export the device geometry as an STL file.\n\n        Parameters\n        ----------\n        thickness_nm : int\n            The thickness of the 3D representation in nanometers.\n        filename : str, optional\n            The name of the STL file to save. Defaults to \"prefab_device.stl\".\n\n        Raises\n        ------\n        ValueError\n            If the thickness is not a positive integer.\n        ImportError\n            If the numpy-stl package is not installed.\n        \"\"\"\n        try:\n            from stl import mesh\n        except ImportError:\n            raise ImportError(\n                \"The stl package is required to use this function; \"\n                \"try `pip install numpy-stl`.\"\n            ) from None\n\n        if thickness_nm &lt;= 0:\n            raise ValueError(\"Thickness must be a positive integer.\")\n\n        layered_array = self.to_3d(thickness_nm)\n        layered_array = np.pad(\n            layered_array, ((0, 0), (0, 0), (10, 10)), mode=\"constant\"\n        )\n        verts, faces, _, _ = measure.marching_cubes(layered_array, level=0.5)\n        cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))\n        for i, f in enumerate(faces):\n            for j in range(3):\n                cube.vectors[i][j] = verts[f[j], :]\n        cube.save(filename)\n        print(f\"Saved Device to '{filename}'\")\n\n    def _plot_base(\n        self,\n        plot_array: np.ndarray,\n        show_buffer: bool,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]],\n        ax: Optional[Axes],\n        **kwargs,\n    ) -&gt; tuple[plt.cm.ScalarMappable, Axes]:\n        if ax is None:\n            _, ax = plt.subplots()\n        ax.set_ylabel(\"y (nm)\")\n        ax.set_xlabel(\"x (nm)\")\n\n        min_x, min_y = (0, 0) if bounds is None else bounds[0]\n        max_x, max_y = plot_array.shape[::-1] if bounds is None else bounds[1]\n        min_x = max(min_x, 0)\n        min_y = max(min_y, 0)\n        max_x = \"end\" if max_x == \"end\" else min(max_x, plot_array.shape[1])\n        max_y = \"end\" if max_y == \"end\" else min(max_y, plot_array.shape[0])\n        max_x = plot_array.shape[1] if max_x == \"end\" else max_x\n        max_y = plot_array.shape[0] if max_y == \"end\" else max_y\n        plot_array = plot_array[\n            plot_array.shape[0] - max_y : plot_array.shape[0] - min_y,\n            min_x:max_x,\n        ]\n        extent = [min_x, max_x, min_y, max_y]\n\n        if not np.ma.is_masked(plot_array):\n            max_size = (1000, 1000)\n            scale_x = min(1, max_size[0] / plot_array.shape[1])\n            scale_y = min(1, max_size[1] / plot_array.shape[0])\n            fx = min(scale_x, scale_y)\n            fy = fx\n\n            plot_array = cv2.resize(\n                plot_array,\n                dsize=(0, 0),\n                fx=fx,\n                fy=fy,\n                interpolation=cv2.INTER_NEAREST,\n            )\n\n        mappable = ax.imshow(\n            plot_array,\n            extent=extent,\n            **kwargs,\n        )\n\n        if show_buffer:\n            self._add_buffer_visualization(ax)\n\n        # # Adjust colorbar font size if a colorbar is added\n        # if \"cmap\" in kwargs:\n        #     cbar = plt.colorbar(mappable, ax=ax)\n        #     cbar.ax.tick_params(labelsize=14)\n        #     if \"label\" in kwargs:\n        #         cbar.set_label(kwargs[\"label\"], fontsize=16)\n\n        return mappable, ax\n\n    def plot(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the device geometry.\n\n        This method allows for the visualization of the device geometry. The\n        visualization can be customized with various matplotlib parameters and can be\n        drawn on an existing matplotlib Axes object or create a new one if none is\n        provided.\n\n        Parameters\n        ----------\n        show_buffer : bool, optional\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the device geometry on. If\n            None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the plot. This object can be used for\n            further plot customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            plot_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            plot_array = self.device_array[:, :, level]\n        _, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        return ax\n\n    def plot_contour(\n        self,\n        linewidth: Optional[int] = None,\n        # label: Optional[str] = \"Device contour\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the contour of the device geometry.\n\n        This method plots the contour of the device geometry, emphasizing the edges and\n        boundaries of the device. The contour plot can be customized with various\n        matplotlib parameters, including line width and color. The plot can be drawn on\n        an existing matplotlib Axes object or create a new one if none is provided.\n\n        Parameters\n        ----------\n        linewidth : Optional[int], optional\n            The width of the contour lines. If None, the linewidth is automatically\n            determined based on the size of the device array. Defaults to None.\n        show_buffer : bool, optional\n            If True, the buffer zones around the device will be visualized. By default,\n            it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the device contour on. If None, a\n            new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the contour plot. This can be used for\n            further customization or saving the plot after the method returns.\n        \"\"\"\n        if level is None:\n            device_array = geometry.flatten(self.device_array)[:, :, 0]\n        else:\n            device_array = self.device_array[:, :, level]\n\n        kwargs.setdefault(\"cmap\", \"spring\")\n        if linewidth is None:\n            linewidth = device_array.shape[0] // 100\n\n        contours, _ = cv2.findContours(\n            geometry.binarize_hard(device_array).astype(np.uint8),\n            cv2.RETR_CCOMP,\n            cv2.CHAIN_APPROX_SIMPLE,\n        )\n        contour_array = np.zeros_like(device_array, dtype=np.uint8)\n        cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n        contour_array = np.ma.masked_equal(contour_array, 0)\n\n        _, ax = self._plot_base(\n            plot_array=contour_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n        # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n        # ax.legend([legend_proxy], [label], loc=\"upper right\")\n        return ax\n\n    def plot_uncertainty(\n        self,\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Visualizes the uncertainty in the edge positions of the predicted device.\n\n        This method plots the uncertainty associated with the positions of the edges of\n        the device. The uncertainty is represented as a gradient, with areas of higher\n        uncertainty indicating a greater likelihood of the edge position from run to run\n        (due to inconsistencies in the fabrication process). This visualization can help\n        in identifying areas within the device geometry that may require design\n        adjustments to improve fabrication consistency.\n\n        Parameters\n        ----------\n        show_buffer : bool, optional\n            If True, the buffer zones around the device will also be visualized. By\n            default, it is set to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the uncertainty visualization on.\n            If None, a new figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the uncertainty visualization. This\n            can be used for further customization or saving the plot after the method\n            returns.\n        \"\"\"\n        uncertainty_array = self.get_uncertainty()\n\n        if level is None:\n            uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n        else:\n            uncertainty_array = uncertainty_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=uncertainty_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Uncertainty (a.u.)\")\n        return ax\n\n    def plot_compare(\n        self,\n        ref_device: \"Device\",\n        show_buffer: bool = True,\n        bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n        level: int = None,\n        ax: Optional[Axes] = None,\n        **kwargs,\n    ) -&gt; Axes:\n        \"\"\"\n        Visualizes the comparison between the current device geometry and a reference\n        device geometry.\n\n        Positive values (dilation) and negative values (erosion) are visualized with a\n        color map to indicate areas where the current device has expanded or contracted\n        relative to the reference.\n\n        Parameters\n        ----------\n        ref_device : Device\n            The reference device to compare against.\n        show_buffer : bool, optional\n            If True, visualizes the buffer zones around the device. Defaults to True.\n        bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n            Specifies the bounds for zooming into the device geometry, formatted as\n            ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n            will be replaced with the corresponding dimension size of the device array.\n            If None, the entire device geometry is visualized.\n        level : int, optional\n            The vertical layer to plot. If None, the device geometry is flattened.\n            Defaults to None.\n        ax : Optional[Axes], optional\n            An existing matplotlib Axes object to draw the comparison on. If None, a new\n            figure and axes will be created. Defaults to None.\n        **kwargs\n            Additional matplotlib parameters for plot customization.\n\n        Returns\n        -------\n        Axes\n            The matplotlib Axes object containing the comparison plot. This object can\n            be used for further plot customization or saving the plot after the method\n            returns.\n        \"\"\"\n        plot_array = ref_device.device_array - self.device_array\n\n        if level is None:\n            plot_array = geometry.flatten(plot_array)[:, :, 0]\n        else:\n            plot_array = plot_array[:, :, level]\n\n        mappable, ax = self._plot_base(\n            plot_array=plot_array,\n            show_buffer=show_buffer,\n            bounds=bounds,\n            ax=ax,\n            cmap=\"jet\",\n            **kwargs,\n        )\n        cbar = plt.colorbar(mappable, ax=ax)\n        cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n        return ax\n\n    def _add_buffer_visualization(self, ax: Axes):\n        plot_array = self.device_array\n\n        buffer_thickness = self.buffer_spec.thickness\n        buffer_fill = (0, 1, 0, 0.2)\n        buffer_hatch = \"/\"\n\n        mid_rect = Rectangle(\n            (buffer_thickness[\"left\"], buffer_thickness[\"top\"]),\n            plot_array.shape[1] - buffer_thickness[\"left\"] - buffer_thickness[\"right\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=\"none\",\n            edgecolor=\"black\",\n            linewidth=1,\n        )\n        ax.add_patch(mid_rect)\n\n        top_rect = Rectangle(\n            (0, 0),\n            plot_array.shape[1],\n            buffer_thickness[\"top\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(top_rect)\n\n        bottom_rect = Rectangle(\n            (0, plot_array.shape[0] - buffer_thickness[\"bottom\"]),\n            plot_array.shape[1],\n            buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(bottom_rect)\n\n        left_rect = Rectangle(\n            (0, buffer_thickness[\"top\"]),\n            buffer_thickness[\"left\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(left_rect)\n\n        right_rect = Rectangle(\n            (\n                plot_array.shape[1] - buffer_thickness[\"right\"],\n                buffer_thickness[\"top\"],\n            ),\n            buffer_thickness[\"right\"],\n            plot_array.shape[0] - buffer_thickness[\"top\"] - buffer_thickness[\"bottom\"],\n            facecolor=buffer_fill,\n            hatch=buffer_hatch,\n        )\n        ax.add_patch(right_rect)\n\n    def normalize(self) -&gt; \"Device\":\n        \"\"\"\n        Normalize the device geometry.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the normalized geometry.\n        \"\"\"\n        normalized_device_array = geometry.normalize(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": normalized_device_array})\n\n    def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry based on a threshold and a scaling factor.\n\n        Parameters\n        ----------\n        eta : float, optional\n            The threshold value for binarization. Defaults to 0.5.\n        beta : float, optional\n            The scaling factor for the binarization process. A higher value makes the\n            transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize(\n            device_array=self.device_array, eta=eta, beta=beta\n        )\n        return self.model_copy(\n            update={\"device_array\": binarized_device_array.astype(np.uint8)}\n        )\n\n    def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n        \"\"\"\n        Apply a hard threshold to binarize the device geometry. The `binarize` function\n        is generally preferred for most use cases, but it can create numerical artifacts\n        for large beta values.\n\n            Parameters\n            ----------\n            eta : float, optional\n                The threshold value for binarization. Defaults to 0.5.\n\n            Returns\n            -------\n            Device\n                A new instance of the Device with the threshold-binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_hard(\n            device_array=self.device_array, eta=eta\n        )\n        return self.model_copy(\n            update={\"device_array\": binarized_device_array.astype(np.uint8)}\n        )\n\n    def binarize_monte_carlo(\n        self,\n        threshold_noise_std: float = 2.0,\n        threshold_blur_std: float = 8.0,\n    ) -&gt; \"Device\":\n        \"\"\"\n        Binarize the device geometry using a Monte Carlo approach with Gaussian\n        blurring.\n\n        This method applies a dynamic thresholding technique where the threshold value\n        is determined by a base value perturbed by Gaussian-distributed random noise.\n        The threshold is then spatially varied across the device array using Gaussian\n        blurring, simulating a more realistic scenario where the threshold is not\n        uniform across the device.\n\n        Parameters\n        ----------\n        threshold_noise_std : float, optional\n            The standard deviation of the Gaussian distribution used to generate noise\n            for the threshold values. This controls the amount of randomness in the\n            threshold. Defaults to 2.0.\n        threshold_blur_std : float, optional\n            The standard deviation for the Gaussian kernel used in blurring the\n            threshold map. This controls the spatial variation of the threshold across\n            the array. Defaults to 9.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the binarized geometry.\n        \"\"\"\n        binarized_device_array = geometry.binarize_monte_carlo(\n            device_array=self.device_array,\n            threshold_noise_std=threshold_noise_std,\n            threshold_blur_std=threshold_blur_std,\n        )\n        return self.model_copy(update={\"device_array\": binarized_device_array})\n\n    def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n        \"\"\"\n        Ternarize the device geometry based on two thresholds. This function is useful\n        for flattened devices with angled sidewalls (i.e., three segments).\n\n        Parameters\n        ----------\n        eta1 : float, optional\n            The first threshold value for ternarization. Defaults to 1/3.\n        eta2 : float, optional\n            The second threshold value for ternarization. Defaults to 2/3.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the ternarized geometry.\n        \"\"\"\n        ternarized_device_array = geometry.ternarize(\n            device_array=self.flatten().device_array, eta1=eta1, eta2=eta2\n        )\n        return self.model_copy(update={\"device_array\": ternarized_device_array})\n\n    def trim(self) -&gt; \"Device\":\n        \"\"\"\n        Trim the device geometry by removing empty space around it.\n\n        Parameters\n        ----------\n        buffer_thickness : dict, optional\n            A dictionary specifying the thickness of the buffer to leave around the\n            non-zero elements of the array. Should contain keys 'top', 'bottom', 'left',\n            'right'. Defaults to None, which means no buffer is added.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the trimmed geometry.\n        \"\"\"\n        trimmed_device_array = geometry.trim(\n            device_array=self.device_array,\n            buffer_thickness=self.buffer_spec.thickness,\n        )\n        return self.model_copy(update={\"device_array\": trimmed_device_array})\n\n    def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n        \"\"\"\n        Apply Gaussian blur to the device geometry and normalize the result.\n\n        Parameters\n        ----------\n        sigma : float, optional\n            The standard deviation for the Gaussian kernel. This controls the amount of\n            blurring. Defaults to 1.0.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the blurred and normalized geometry.\n        \"\"\"\n        blurred_device_array = geometry.blur(\n            device_array=self.device_array, sigma=sigma\n        )\n        return self.model_copy(update={\"device_array\": blurred_device_array})\n\n    def rotate(self, angle: float) -&gt; \"Device\":\n        \"\"\"\n        Rotate the device geometry by a given angle.\n\n        Parameters\n        ----------\n        angle : float\n            The angle of rotation in degrees. Positive values mean counter-clockwise\n            rotation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the rotated geometry.\n        \"\"\"\n        rotated_device_array = geometry.rotate(\n            device_array=self.device_array, angle=angle\n        )\n        return self.model_copy(update={\"device_array\": rotated_device_array})\n\n    def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Erode the device geometry by removing small areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for erosion.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the eroded geometry.\n        \"\"\"\n        eroded_device_array = geometry.erode(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": eroded_device_array})\n\n    def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n        \"\"\"\n        Dilate the device geometry by expanding areas of overlap.\n\n        Parameters\n        ----------\n        kernel_size : int\n            The size of the kernel used for dilation.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the dilated geometry.\n        \"\"\"\n        dilated_device_array = geometry.dilate(\n            device_array=self.device_array, kernel_size=kernel_size\n        )\n        return self.model_copy(update={\"device_array\": dilated_device_array})\n\n    def flatten(self) -&gt; \"Device\":\n        \"\"\"\n        Flatten the device geometry by summing the vertical layers and normalizing the\n        result.\n\n        Parameters\n        ----------\n        device_array : np.ndarray\n            The input array to be flattened.\n\n        Returns\n        -------\n        np.ndarray\n            The flattened array with values scaled between 0 and 1.\n        \"\"\"\n        flattened_device_array = geometry.flatten(device_array=self.device_array)\n        return self.model_copy(update={\"device_array\": flattened_device_array})\n\n    def get_uncertainty(self) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the uncertainty in the edge positions of the predicted device.\n\n        This method computes the uncertainty based on the deviation of the device's\n        geometry values from the midpoint (0.5). The uncertainty is defined as the\n        absolute difference from 0.5, scaled and inverted to provide a measure where\n        higher values indicate greater uncertainty.\n\n        Returns\n        -------\n        np.ndarray\n            An array representing the uncertainty in the edge positions of the device,\n            with higher values indicating greater uncertainty.\n        \"\"\"\n        return 1 - 2 * np.abs(0.5 - self.device_array)\n\n    def enforce_feature_size(\n        self, min_feature_size: int, strel: str = \"disk\"\n    ) -&gt; \"Device\":\n        \"\"\"\n        Enforce a minimum feature size on the device geometry.\n\n        This method applies morphological operations to ensure that all features in the\n        device geometry are at least the specified minimum size. It uses either a disk\n        or square structuring element for the operations.\n\n        Parameters\n        ----------\n        min_feature_size : int\n            The minimum feature size to enforce, in nanometers.\n        strel : str, optional\n            The type of structuring element to use. Can be either \"disk\" or \"square\".\n            Defaults to \"disk\".\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the modified geometry.\n\n        Raises\n        ------\n        ValueError\n            If an invalid structuring element type is specified.\n        \"\"\"\n        if strel == \"disk\":\n            structuring_element = disk(radius=min_feature_size / 2)\n        elif strel == \"square\":\n            structuring_element = square(width=min_feature_size)\n        else:\n            raise ValueError(f\"Invalid structuring element: {strel}\")\n\n        modified_geometry = closing(self.device_array[:, :, 0], structuring_element)\n        modified_geometry = opening(modified_geometry, structuring_element)\n        modified_geometry = np.expand_dims(modified_geometry, axis=-1)\n        return self.model_copy(update={\"device_array\": modified_geometry})\n\n    def check_feature_size(self, min_feature_size: int, strel: str = \"disk\"):\n        \"\"\"\n        Check and visualize the effect of enforcing a minimum feature size on the device\n        geometry.\n\n        This method enforces a minimum feature size on the device geometry using the\n        specified structuring element, compares the modified geometry with the original,\n        and plots the differences. It also calculates and prints the Hamming distance\n        between the original and modified geometries, providing a measure of the changes\n        introduced by the feature size enforcement.\n\n        Parameters\n        ----------\n        min_feature_size : int\n            The minimum feature size to enforce, in nanometers.\n        strel : str, optional\n            The type of structuring element to use. Can be either \"disk\" or \"square\".\n            Defaults to \"disk\".\n\n        Raises\n        ------\n        ValueError\n            If an invalid structuring element type is specified or if min_feature_size\n            is not a positive integer.\n        \"\"\"\n        if min_feature_size &lt;= 0:\n            raise ValueError(\"min_feature_size must be a positive integer.\")\n\n        enforced_device = self.enforce_feature_size(min_feature_size, strel)\n\n        difference = np.abs(\n            enforced_device.device_array[:, :, 0] - self.device_array[:, :, 0]\n        )\n        _, ax = self._plot_base(\n            plot_array=difference,\n            show_buffer=False,\n            ax=None,\n            bounds=None,\n            cmap=\"jet\",\n        )\n\n        hamming_distance = compare.hamming_distance(self, enforced_device)\n        print(\n            f\"Feature size check with minimum size {min_feature_size} \"\n            f\"using '{strel}' structuring element resulted in a Hamming \"\n            f\"distance of: {hamming_distance}\"\n        )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.__init__","title":"<code>__init__(device_array, buffer_spec=None)</code>","text":"<p>Represents the planar geometry of a photonic device design that will have its nanofabrication outcome predicted and/or corrected.</p> <p>This class is designed to encapsulate the geometric representation of a photonic device, facilitating operations such as padding, normalization, binarization, ternarization, trimming, and blurring. These operations are useful for preparing the device design for prediction or correction. Additionally, the class provides methods for exporting the device representation to various formats, including ndarray, image files, and GDSII files, supporting a range of analysis and fabrication workflows.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>A 2D array representing the planar geometry of the device. This array undergoes various transformations to predict or correct the nanofabrication process.</p> required <code>buffer_spec</code> <code>BufferSpec</code> <p>Defines the parameters for adding a buffer zone around the device geometry. This buffer zone is needed for providing surrounding context for prediction or correction and for ensuring seamless integration with the surrounding circuitry. By default, a generous padding is applied to accommodate isolated structures.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>shape</code> <code>tuple[int, int]</code> <p>The shape of the device array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided <code>device_array</code> is not a numpy ndarray or is not a 2D array, indicating an invalid device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def __init__(\n    self, device_array: np.ndarray, buffer_spec: Optional[BufferSpec] = None\n):\n    \"\"\"\n    Represents the planar geometry of a photonic device design that will have its\n    nanofabrication outcome predicted and/or corrected.\n\n    This class is designed to encapsulate the geometric representation of a photonic\n    device, facilitating operations such as padding, normalization, binarization,\n    ternarization, trimming, and blurring. These operations are useful for preparing\n    the device design for prediction or correction. Additionally, the class provides\n    methods for exporting the device representation to various formats, including\n    ndarray, image files, and GDSII files, supporting a range of analysis and\n    fabrication workflows.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        A 2D array representing the planar geometry of the device. This array\n        undergoes various transformations to predict or correct the nanofabrication\n        process.\n    buffer_spec : BufferSpec, optional\n        Defines the parameters for adding a buffer zone around the device geometry.\n        This buffer zone is needed for providing surrounding context for prediction\n        or correction and for ensuring seamless integration with the surrounding\n        circuitry. By default, a generous padding is applied to accommodate isolated\n        structures.\n\n    Attributes\n    ----------\n    shape : tuple[int, int]\n        The shape of the device array.\n\n    Raises\n    ------\n    ValueError\n        If the provided `device_array` is not a numpy ndarray or is not a 2D array,\n        indicating an invalid device geometry.\n    \"\"\"\n    super().__init__(\n        device_array=device_array, buffer_spec=buffer_spec or BufferSpec()\n    )\n    self._initial_processing()\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize","title":"<code>binarize(eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the device geometry based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize(self, eta: float = 0.5, beta: float = np.inf) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float, optional\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize(\n        device_array=self.device_array, eta=eta, beta=beta\n    )\n    return self.model_copy(\n        update={\"device_array\": binarized_device_array.astype(np.uint8)}\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_hard","title":"<code>binarize_hard(eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the device geometry. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <pre><code>Parameters\n</code></pre> <pre><code>eta : float, optional\n    The threshold value for binarization. Defaults to 0.5.\n</code></pre> <pre><code>Returns\n</code></pre> <pre><code>Device\n    A new instance of the Device with the threshold-binarized geometry.\n</code></pre> Source code in <code>prefab/device.py</code> <pre><code>def binarize_hard(self, eta: float = 0.5) -&gt; \"Device\":\n    \"\"\"\n    Apply a hard threshold to binarize the device geometry. The `binarize` function\n    is generally preferred for most use cases, but it can create numerical artifacts\n    for large beta values.\n\n        Parameters\n        ----------\n        eta : float, optional\n            The threshold value for binarization. Defaults to 0.5.\n\n        Returns\n        -------\n        Device\n            A new instance of the Device with the threshold-binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_hard(\n        device_array=self.device_array, eta=eta\n    )\n    return self.model_copy(\n        update={\"device_array\": binarized_device_array.astype(np.uint8)}\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.binarize_monte_carlo","title":"<code>binarize_monte_carlo(threshold_noise_std=2.0, threshold_blur_std=8.0)</code>","text":"<p>Binarize the device geometry using a Monte Carlo approach with Gaussian blurring.</p> <p>This method applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the device array using Gaussian blurring, simulating a more realistic scenario where the threshold is not uniform across the device.</p> <p>Parameters:</p> Name Type Description Default <code>threshold_noise_std</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold. Defaults to 2.0.</p> <code>2.0</code> <code>threshold_blur_std</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array. Defaults to 9.0.</p> <code>8.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the binarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def binarize_monte_carlo(\n    self,\n    threshold_noise_std: float = 2.0,\n    threshold_blur_std: float = 8.0,\n) -&gt; \"Device\":\n    \"\"\"\n    Binarize the device geometry using a Monte Carlo approach with Gaussian\n    blurring.\n\n    This method applies a dynamic thresholding technique where the threshold value\n    is determined by a base value perturbed by Gaussian-distributed random noise.\n    The threshold is then spatially varied across the device array using Gaussian\n    blurring, simulating a more realistic scenario where the threshold is not\n    uniform across the device.\n\n    Parameters\n    ----------\n    threshold_noise_std : float, optional\n        The standard deviation of the Gaussian distribution used to generate noise\n        for the threshold values. This controls the amount of randomness in the\n        threshold. Defaults to 2.0.\n    threshold_blur_std : float, optional\n        The standard deviation for the Gaussian kernel used in blurring the\n        threshold map. This controls the spatial variation of the threshold across\n        the array. Defaults to 9.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the binarized geometry.\n    \"\"\"\n    binarized_device_array = geometry.binarize_monte_carlo(\n        device_array=self.device_array,\n        threshold_noise_std=threshold_noise_std,\n        threshold_blur_std=threshold_blur_std,\n    )\n    return self.model_copy(update={\"device_array\": binarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.blur","title":"<code>blur(sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the device geometry and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the blurred and normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def blur(self, sigma: float = 1.0) -&gt; \"Device\":\n    \"\"\"\n    Apply Gaussian blur to the device geometry and normalize the result.\n\n    Parameters\n    ----------\n    sigma : float, optional\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the blurred and normalized geometry.\n    \"\"\"\n    blurred_device_array = geometry.blur(\n        device_array=self.device_array, sigma=sigma\n    )\n    return self.model_copy(update={\"device_array\": blurred_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.check_feature_size","title":"<code>check_feature_size(min_feature_size, strel='disk')</code>","text":"<p>Check and visualize the effect of enforcing a minimum feature size on the device geometry.</p> <p>This method enforces a minimum feature size on the device geometry using the specified structuring element, compares the modified geometry with the original, and plots the differences. It also calculates and prints the Hamming distance between the original and modified geometries, providing a measure of the changes introduced by the feature size enforcement.</p> <p>Parameters:</p> Name Type Description Default <code>min_feature_size</code> <code>int</code> <p>The minimum feature size to enforce, in nanometers.</p> required <code>strel</code> <code>str</code> <p>The type of structuring element to use. Can be either \"disk\" or \"square\". Defaults to \"disk\".</p> <code>'disk'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid structuring element type is specified or if min_feature_size is not a positive integer.</p> Source code in <code>prefab/device.py</code> <pre><code>def check_feature_size(self, min_feature_size: int, strel: str = \"disk\"):\n    \"\"\"\n    Check and visualize the effect of enforcing a minimum feature size on the device\n    geometry.\n\n    This method enforces a minimum feature size on the device geometry using the\n    specified structuring element, compares the modified geometry with the original,\n    and plots the differences. It also calculates and prints the Hamming distance\n    between the original and modified geometries, providing a measure of the changes\n    introduced by the feature size enforcement.\n\n    Parameters\n    ----------\n    min_feature_size : int\n        The minimum feature size to enforce, in nanometers.\n    strel : str, optional\n        The type of structuring element to use. Can be either \"disk\" or \"square\".\n        Defaults to \"disk\".\n\n    Raises\n    ------\n    ValueError\n        If an invalid structuring element type is specified or if min_feature_size\n        is not a positive integer.\n    \"\"\"\n    if min_feature_size &lt;= 0:\n        raise ValueError(\"min_feature_size must be a positive integer.\")\n\n    enforced_device = self.enforce_feature_size(min_feature_size, strel)\n\n    difference = np.abs(\n        enforced_device.device_array[:, :, 0] - self.device_array[:, :, 0]\n    )\n    _, ax = self._plot_base(\n        plot_array=difference,\n        show_buffer=False,\n        ax=None,\n        bounds=None,\n        cmap=\"jet\",\n    )\n\n    hamming_distance = compare.hamming_distance(self, enforced_device)\n    print(\n        f\"Feature size check with minimum size {min_feature_size} \"\n        f\"using '{strel}' structuring element resulted in a Hamming \"\n        f\"distance of: {hamming_distance}\"\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.correct","title":"<code>correct(model, binarize=True, gpu=False)</code>","text":"<p>Correct the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless correction service, which uses a specified machine learning model to correct the outcome of the nanofabrication process. The correction aims to adjust the device geometry to compensate for known fabrication errors and improve the accuracy of the final device structure.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for correction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the correction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the corrected device geometry will be binarized using a threshold method. This is useful for converting probabilistic corrections into binary geometries. Defaults to True.</p> <code>True</code> <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the corrected geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the correction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def correct(\n    self,\n    model: Model,\n    binarize: bool = True,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Correct the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless correction service, which\n    uses a specified machine learning model to correct the outcome of the\n    nanofabrication process. The correction aims to adjust the device geometry to\n    compensate for known fabrication errors and improve the accuracy of the final\n    device structure.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for correction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the correction\n        is tailored to specific fabrication parameters.\n    binarize : bool, optional\n        If True, the corrected device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic corrections into binary\n        geometries. Defaults to True.\n    gpu : bool, optional\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the corrected geometry.\n\n    Raises\n    ------\n    ValueError\n        If the correction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    correction_array = self._predict_array(\n        model=model,\n        model_type=\"c\",\n        binarize=binarize,\n        gpu=gpu,\n    )\n    return self.model_copy(update={\"device_array\": correction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.dilate","title":"<code>dilate(kernel_size=3)</code>","text":"<p>Dilate the device geometry by expanding areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the dilated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def dilate(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Dilate the device geometry by expanding areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the dilated geometry.\n    \"\"\"\n    dilated_device_array = geometry.dilate(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": dilated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.enforce_feature_size","title":"<code>enforce_feature_size(min_feature_size, strel='disk')</code>","text":"<p>Enforce a minimum feature size on the device geometry.</p> <p>This method applies morphological operations to ensure that all features in the device geometry are at least the specified minimum size. It uses either a disk or square structuring element for the operations.</p> <p>Parameters:</p> Name Type Description Default <code>min_feature_size</code> <code>int</code> <p>The minimum feature size to enforce, in nanometers.</p> required <code>strel</code> <code>str</code> <p>The type of structuring element to use. Can be either \"disk\" or \"square\". Defaults to \"disk\".</p> <code>'disk'</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the modified geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid structuring element type is specified.</p> Source code in <code>prefab/device.py</code> <pre><code>def enforce_feature_size(\n    self, min_feature_size: int, strel: str = \"disk\"\n) -&gt; \"Device\":\n    \"\"\"\n    Enforce a minimum feature size on the device geometry.\n\n    This method applies morphological operations to ensure that all features in the\n    device geometry are at least the specified minimum size. It uses either a disk\n    or square structuring element for the operations.\n\n    Parameters\n    ----------\n    min_feature_size : int\n        The minimum feature size to enforce, in nanometers.\n    strel : str, optional\n        The type of structuring element to use. Can be either \"disk\" or \"square\".\n        Defaults to \"disk\".\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the modified geometry.\n\n    Raises\n    ------\n    ValueError\n        If an invalid structuring element type is specified.\n    \"\"\"\n    if strel == \"disk\":\n        structuring_element = disk(radius=min_feature_size / 2)\n    elif strel == \"square\":\n        structuring_element = square(width=min_feature_size)\n    else:\n        raise ValueError(f\"Invalid structuring element: {strel}\")\n\n    modified_geometry = closing(self.device_array[:, :, 0], structuring_element)\n    modified_geometry = opening(modified_geometry, structuring_element)\n    modified_geometry = np.expand_dims(modified_geometry, axis=-1)\n    return self.model_copy(update={\"device_array\": modified_geometry})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.erode","title":"<code>erode(kernel_size=3)</code>","text":"<p>Erode the device geometry by removing small areas of overlap.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> <code>3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the eroded geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def erode(self, kernel_size: int = 3) -&gt; \"Device\":\n    \"\"\"\n    Erode the device geometry by removing small areas of overlap.\n\n    Parameters\n    ----------\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the eroded geometry.\n    \"\"\"\n    eroded_device_array = geometry.erode(\n        device_array=self.device_array, kernel_size=kernel_size\n    )\n    return self.model_copy(update={\"device_array\": eroded_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.flatten","title":"<code>flatten()</code>","text":"<p>Flatten the device geometry by summing the vertical layers and normalizing the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be flattened.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The flattened array with values scaled between 0 and 1.</p> Source code in <code>prefab/device.py</code> <pre><code>def flatten(self) -&gt; \"Device\":\n    \"\"\"\n    Flatten the device geometry by summing the vertical layers and normalizing the\n    result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be flattened.\n\n    Returns\n    -------\n    np.ndarray\n        The flattened array with values scaled between 0 and 1.\n    \"\"\"\n    flattened_device_array = geometry.flatten(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": flattened_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.get_uncertainty","title":"<code>get_uncertainty()</code>","text":"<p>Calculate the uncertainty in the edge positions of the predicted device.</p> <p>This method computes the uncertainty based on the deviation of the device's geometry values from the midpoint (0.5). The uncertainty is defined as the absolute difference from 0.5, scaled and inverted to provide a measure where higher values indicate greater uncertainty.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing the uncertainty in the edge positions of the device, with higher values indicating greater uncertainty.</p> Source code in <code>prefab/device.py</code> <pre><code>def get_uncertainty(self) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the uncertainty in the edge positions of the predicted device.\n\n    This method computes the uncertainty based on the deviation of the device's\n    geometry values from the midpoint (0.5). The uncertainty is defined as the\n    absolute difference from 0.5, scaled and inverted to provide a measure where\n    higher values indicate greater uncertainty.\n\n    Returns\n    -------\n    np.ndarray\n        An array representing the uncertainty in the edge positions of the device,\n        with higher values indicating greater uncertainty.\n    \"\"\"\n    return 1 - 2 * np.abs(0.5 - self.device_array)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.is_binary","title":"<code>is_binary()</code>","text":"<p>Check if the device geometry is binary.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the device geometry is binary, False otherwise.</p> Source code in <code>prefab/device.py</code> <pre><code>def is_binary(self) -&gt; bool:\n    \"\"\"\n    Check if the device geometry is binary.\n\n    Returns\n    -------\n    bool\n        True if the device geometry is binary, False otherwise.\n    \"\"\"\n    unique_values = np.unique(self.device_array)\n    return (\n        np.array_equal(unique_values, [0, 1])\n        or np.array_equal(unique_values, [1, 0])\n        or np.array_equal(unique_values, [0])\n        or np.array_equal(unique_values, [1])\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.normalize","title":"<code>normalize()</code>","text":"<p>Normalize the device geometry.</p> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the normalized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def normalize(self) -&gt; \"Device\":\n    \"\"\"\n    Normalize the device geometry.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the normalized geometry.\n    \"\"\"\n    normalized_device_array = geometry.normalize(device_array=self.device_array)\n    return self.model_copy(update={\"device_array\": normalized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot","title":"<code>plot(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the device geometry.</p> <p>This method allows for the visualization of the device geometry. The visualization can be customized with various matplotlib parameters and can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device geometry on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the device geometry.\n\n    This method allows for the visualization of the device geometry. The\n    visualization can be customized with various matplotlib parameters and can be\n    drawn on an existing matplotlib Axes object or create a new one if none is\n    provided.\n\n    Parameters\n    ----------\n    show_buffer : bool, optional\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the device geometry on. If\n        None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the plot. This object can be used for\n        further plot customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        plot_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        plot_array = self.device_array[:, :, level]\n    _, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_compare","title":"<code>plot_compare(ref_device, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the comparison between the current device geometry and a reference device geometry.</p> <p>Positive values (dilation) and negative values (erosion) are visualized with a color map to indicate areas where the current device has expanded or contracted relative to the reference.</p> <p>Parameters:</p> Name Type Description Default <code>ref_device</code> <code>Device</code> <p>The reference device to compare against.</p> required <code>show_buffer</code> <code>bool</code> <p>If True, visualizes the buffer zones around the device. Defaults to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the comparison on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the comparison plot. This object can be used for further plot customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_compare(\n    self,\n    ref_device: \"Device\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n) -&gt; Axes:\n    \"\"\"\n    Visualizes the comparison between the current device geometry and a reference\n    device geometry.\n\n    Positive values (dilation) and negative values (erosion) are visualized with a\n    color map to indicate areas where the current device has expanded or contracted\n    relative to the reference.\n\n    Parameters\n    ----------\n    ref_device : Device\n        The reference device to compare against.\n    show_buffer : bool, optional\n        If True, visualizes the buffer zones around the device. Defaults to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the comparison on. If None, a new\n        figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the comparison plot. This object can\n        be used for further plot customization or saving the plot after the method\n        returns.\n    \"\"\"\n    plot_array = ref_device.device_array - self.device_array\n\n    if level is None:\n        plot_array = geometry.flatten(plot_array)[:, :, 0]\n    else:\n        plot_array = plot_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=plot_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        cmap=\"jet\",\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Added (a.u.)                        Removed (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_contour","title":"<code>plot_contour(linewidth=None, show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the contour of the device geometry.</p> <p>This method plots the contour of the device geometry, emphasizing the edges and boundaries of the device. The contour plot can be customized with various matplotlib parameters, including line width and color. The plot can be drawn on an existing matplotlib Axes object or create a new one if none is provided.</p> <p>Parameters:</p> Name Type Description Default <code>linewidth</code> <code>Optional[int]</code> <p>The width of the contour lines. If None, the linewidth is automatically determined based on the size of the device array. Defaults to None.</p> <code>None</code> <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the device contour on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the contour plot. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_contour(\n    self,\n    linewidth: Optional[int] = None,\n    # label: Optional[str] = \"Device contour\",\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the contour of the device geometry.\n\n    This method plots the contour of the device geometry, emphasizing the edges and\n    boundaries of the device. The contour plot can be customized with various\n    matplotlib parameters, including line width and color. The plot can be drawn on\n    an existing matplotlib Axes object or create a new one if none is provided.\n\n    Parameters\n    ----------\n    linewidth : Optional[int], optional\n        The width of the contour lines. If None, the linewidth is automatically\n        determined based on the size of the device array. Defaults to None.\n    show_buffer : bool, optional\n        If True, the buffer zones around the device will be visualized. By default,\n        it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the device contour on. If None, a\n        new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the contour plot. This can be used for\n        further customization or saving the plot after the method returns.\n    \"\"\"\n    if level is None:\n        device_array = geometry.flatten(self.device_array)[:, :, 0]\n    else:\n        device_array = self.device_array[:, :, level]\n\n    kwargs.setdefault(\"cmap\", \"spring\")\n    if linewidth is None:\n        linewidth = device_array.shape[0] // 100\n\n    contours, _ = cv2.findContours(\n        geometry.binarize_hard(device_array).astype(np.uint8),\n        cv2.RETR_CCOMP,\n        cv2.CHAIN_APPROX_SIMPLE,\n    )\n    contour_array = np.zeros_like(device_array, dtype=np.uint8)\n    cv2.drawContours(contour_array, contours, -1, (255,), linewidth)\n    contour_array = np.ma.masked_equal(contour_array, 0)\n\n    _, ax = self._plot_base(\n        plot_array=contour_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    # cmap = cm.get_cmap(kwargs.get(\"cmap\", \"spring\"))\n    # legend_proxy = Line2D([0], [0], linestyle=\"-\", color=cmap(1))\n    # ax.legend([legend_proxy], [label], loc=\"upper right\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.plot_uncertainty","title":"<code>plot_uncertainty(show_buffer=True, bounds=None, level=None, ax=None, **kwargs)</code>","text":"<p>Visualizes the uncertainty in the edge positions of the predicted device.</p> <p>This method plots the uncertainty associated with the positions of the edges of the device. The uncertainty is represented as a gradient, with areas of higher uncertainty indicating a greater likelihood of the edge position from run to run (due to inconsistencies in the fabrication process). This visualization can help in identifying areas within the device geometry that may require design adjustments to improve fabrication consistency.</p> <p>Parameters:</p> Name Type Description Default <code>show_buffer</code> <code>bool</code> <p>If True, the buffer zones around the device will also be visualized. By default, it is set to True.</p> <code>True</code> <code>bounds</code> <code>Optional[tuple[tuple[int, int], tuple[int, int]]]</code> <p>Specifies the bounds for zooming into the device geometry, formatted as ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it will be replaced with the corresponding dimension size of the device array. If None, the entire device geometry is visualized.</p> <code>None</code> <code>level</code> <code>int</code> <p>The vertical layer to plot. If None, the device geometry is flattened. Defaults to None.</p> <code>None</code> <code>ax</code> <code>Optional[Axes]</code> <p>An existing matplotlib Axes object to draw the uncertainty visualization on. If None, a new figure and axes will be created. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional matplotlib parameters for plot customization.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib Axes object containing the uncertainty visualization. This can be used for further customization or saving the plot after the method returns.</p> Source code in <code>prefab/device.py</code> <pre><code>def plot_uncertainty(\n    self,\n    show_buffer: bool = True,\n    bounds: Optional[tuple[tuple[int, int], tuple[int, int]]] = None,\n    level: int = None,\n    ax: Optional[Axes] = None,\n    **kwargs,\n):\n    \"\"\"\n    Visualizes the uncertainty in the edge positions of the predicted device.\n\n    This method plots the uncertainty associated with the positions of the edges of\n    the device. The uncertainty is represented as a gradient, with areas of higher\n    uncertainty indicating a greater likelihood of the edge position from run to run\n    (due to inconsistencies in the fabrication process). This visualization can help\n    in identifying areas within the device geometry that may require design\n    adjustments to improve fabrication consistency.\n\n    Parameters\n    ----------\n    show_buffer : bool, optional\n        If True, the buffer zones around the device will also be visualized. By\n        default, it is set to True.\n    bounds : Optional[tuple[tuple[int, int], tuple[int, int]]], optional\n        Specifies the bounds for zooming into the device geometry, formatted as\n        ((min_x, min_y), (max_x, max_y)). If 'max_x' or 'max_y' is set to \"end\", it\n        will be replaced with the corresponding dimension size of the device array.\n        If None, the entire device geometry is visualized.\n    level : int, optional\n        The vertical layer to plot. If None, the device geometry is flattened.\n        Defaults to None.\n    ax : Optional[Axes], optional\n        An existing matplotlib Axes object to draw the uncertainty visualization on.\n        If None, a new figure and axes will be created. Defaults to None.\n    **kwargs\n        Additional matplotlib parameters for plot customization.\n\n    Returns\n    -------\n    Axes\n        The matplotlib Axes object containing the uncertainty visualization. This\n        can be used for further customization or saving the plot after the method\n        returns.\n    \"\"\"\n    uncertainty_array = self.get_uncertainty()\n\n    if level is None:\n        uncertainty_array = geometry.flatten(uncertainty_array)[:, :, 0]\n    else:\n        uncertainty_array = uncertainty_array[:, :, level]\n\n    mappable, ax = self._plot_base(\n        plot_array=uncertainty_array,\n        show_buffer=show_buffer,\n        bounds=bounds,\n        ax=ax,\n        **kwargs,\n    )\n    cbar = plt.colorbar(mappable, ax=ax)\n    cbar.set_label(\"Uncertainty (a.u.)\")\n    return ax\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.predict","title":"<code>predict(model, binarize=False, gpu=False)</code>","text":"<p>Predict the nanofabrication outcome of the device using a specified model.</p> <p>This method sends the device geometry to a serverless prediction service, which uses a specified machine learning model to predict the outcome of the nanofabrication process.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for prediction, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the prediction is tailored to specific fabrication parameters.</p> required <code>binarize</code> <code>bool</code> <p>If True, the predicted device geometry will be binarized using a threshold method. This is useful for converting probabilistic predictions into binary geometries. Defaults to False.</p> <code>False</code> <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with the predicted geometry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the prediction service returns an error or if the response from the service cannot be processed correctly.</p> Source code in <code>prefab/device.py</code> <pre><code>def predict(\n    self,\n    model: Model,\n    binarize: bool = False,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Predict the nanofabrication outcome of the device using a specified model.\n\n    This method sends the device geometry to a serverless prediction service, which\n    uses a specified machine learning model to predict the outcome of the\n    nanofabrication process.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for prediction, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the prediction\n        is tailored to specific fabrication parameters.\n    binarize : bool, optional\n        If True, the predicted device geometry will be binarized using a threshold\n        method. This is useful for converting probabilistic predictions into binary\n        geometries. Defaults to False.\n    gpu : bool, optional\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with the predicted geometry.\n\n    Raises\n    ------\n    ValueError\n        If the prediction service returns an error or if the response from the\n        service cannot be processed correctly.\n    \"\"\"\n    prediction_array = self._predict_array(\n        model=model,\n        model_type=\"p\",\n        binarize=binarize,\n        gpu=gpu,\n    )\n    return self.model_copy(update={\"device_array\": prediction_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.rotate","title":"<code>rotate(angle)</code>","text":"<p>Rotate the device geometry by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the rotated geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def rotate(self, angle: float) -&gt; \"Device\":\n    \"\"\"\n    Rotate the device geometry by a given angle.\n\n    Parameters\n    ----------\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the rotated geometry.\n    \"\"\"\n    rotated_device_array = geometry.rotate(\n        device_array=self.device_array, angle=angle\n    )\n    return self.model_copy(update={\"device_array\": rotated_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.semulate","title":"<code>semulate(model, gpu=False)</code>","text":"<p>Simulate the appearance of the device as if viewed under a scanning electron microscope (SEM).</p> <p>This method applies a specified machine learning model to transform the device geometry into a style that resembles an SEM image. This can be useful for visualizing how the device might appear under an SEM, which is often used for inspecting the surface and composition of materials at high magnification.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to use for SEMulation, representing a specific fabrication process and dataset. This model encapsulates details about the fabrication foundry, process, material, technology, thickness, and sidewall presence, as defined in <code>models.py</code>. Each model is associated with a version and dataset that detail its creation and the data it was trained on, ensuring the SEMulation is tailored to specific fabrication parameters.</p> required <code>gpu</code> <code>bool</code> <p>If True, the prediction will be performed on a GPU. Defaults to False. Note: The GPU option has more overhead and will take longer for small devices, but will be faster for larger devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device class with its geometry transformed to simulate an SEM image style.</p> Source code in <code>prefab/device.py</code> <pre><code>def semulate(\n    self,\n    model: Model,\n    gpu: bool = False,\n) -&gt; \"Device\":\n    \"\"\"\n    Simulate the appearance of the device as if viewed under a scanning electron\n    microscope (SEM).\n\n    This method applies a specified machine learning model to transform the device\n    geometry into a style that resembles an SEM image. This can be useful for\n    visualizing how the device might appear under an SEM, which is often used for\n    inspecting the surface and composition of materials at high magnification.\n\n    Parameters\n    ----------\n    model : Model\n        The model to use for SEMulation, representing a specific fabrication process\n        and dataset. This model encapsulates details about the fabrication foundry,\n        process, material, technology, thickness, and sidewall presence, as defined\n        in `models.py`. Each model is associated with a version and dataset that\n        detail its creation and the data it was trained on, ensuring the SEMulation\n        is tailored to specific fabrication parameters.\n    gpu : bool, optional\n        If True, the prediction will be performed on a GPU. Defaults to False.\n        Note: The GPU option has more overhead and will take longer for small\n        devices, but will be faster for larger devices.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device class with its geometry transformed to simulate\n        an SEM image style.\n    \"\"\"\n    semulated_array = self._predict_array(\n        model=model,\n        model_type=\"s\",\n        binarize=False,\n        gpu=gpu,\n    )\n    semulated_array += np.random.normal(0, 0.03, semulated_array.shape)\n    return self.model_copy(update={\"device_array\": semulated_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.ternarize","title":"<code>ternarize(eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the device geometry based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the ternarized geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def ternarize(self, eta1: float = 1 / 3, eta2: float = 2 / 3) -&gt; \"Device\":\n    \"\"\"\n    Ternarize the device geometry based on two thresholds. This function is useful\n    for flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    eta1 : float, optional\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float, optional\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the ternarized geometry.\n    \"\"\"\n    ternarized_device_array = geometry.ternarize(\n        device_array=self.flatten().device_array, eta1=eta1, eta2=eta2\n    )\n    return self.model_copy(update={\"device_array\": ternarized_device_array})\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_3d","title":"<code>to_3d(thickness_nm)</code>","text":"<p>Convert the 2D device geometry into a 3D representation.</p> <p>This method creates a 3D array by interpolating between the bottom and top layers of the device geometry. The interpolation is linear.</p> <p>Parameters:</p> Name Type Description Default <code>thickness_nm</code> <code>int</code> <p>The thickness of the 3D representation in nanometers.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 3D narray representing the device geometry with the specified thickness.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_3d(self, thickness_nm: int) -&gt; np.ndarray:\n    \"\"\"\n    Convert the 2D device geometry into a 3D representation.\n\n    This method creates a 3D array by interpolating between the bottom and top\n    layers of the device geometry. The interpolation is linear.\n\n    Parameters\n    ----------\n    thickness_nm : int\n        The thickness of the 3D representation in nanometers.\n\n    Returns\n    -------\n    np.ndarray\n        A 3D narray representing the device geometry with the specified thickness.\n    \"\"\"\n    bottom_layer = self.device_array[:, :, 0]\n    top_layer = self.device_array[:, :, -1]\n    dt_bottom = distance_transform_edt(bottom_layer) - distance_transform_edt(\n        1 - bottom_layer\n    )\n    dt_top = distance_transform_edt(top_layer) - distance_transform_edt(\n        1 - top_layer\n    )\n    weights = np.linspace(0, 1, thickness_nm)\n    layered_array = np.zeros(\n        (bottom_layer.shape[0], bottom_layer.shape[1], thickness_nm)\n    )\n    for i, w in enumerate(weights):\n        dt_interp = (1 - w) * dt_bottom + w * dt_top\n        layered_array[:, :, i] = dt_interp &gt;= 0\n    return layered_array\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gds","title":"<code>to_gds(gds_path='prefab_device.gds', cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2)</code>","text":"<p>Exports the device geometry as a GDSII file.</p> <p>This method converts the device geometry into a format suitable for GDSII files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The path where the GDSII file will be saved. If not specified, the file is saved as \"prefab_device.gds\" in the current directory.</p> <code>'prefab_device.gds'</code> <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDSII file. If not specified, defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSII file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> Source code in <code>prefab/device.py</code> <pre><code>def to_gds(\n    self,\n    gds_path: str = \"prefab_device.gds\",\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n):\n    \"\"\"\n    Exports the device geometry as a GDSII file.\n\n    This method converts the device geometry into a format suitable for GDSII files.\n    The conversion involves contour approximation to simplify the geometry while\n    preserving essential features.\n\n    Parameters\n    ----------\n    gds_path : str, optional\n        The path where the GDSII file will be saved. If not specified, the file is\n        saved as \"prefab_device.gds\" in the current directory.\n    cell_name : str, optional\n        The name of the cell within the GDSII file. If not specified, defaults to\n        \"prefab_device\".\n    gds_layer : tuple[int, int], optional\n        The layer and datatype to use within the GDSII file. Defaults to (1, 0).\n    contour_approx_mode : int, optional\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n    \"\"\"\n    gdstk_cell = self.flatten()._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n    )\n    print(f\"Saving GDS to '{gds_path}'...\")\n    gdstk_library = gdstk.Library()\n    gdstk_library.add(gdstk_cell)\n    gdstk_library.write_gds(outfile=gds_path, max_points=8190)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gdsfactory","title":"<code>to_gdsfactory()</code>","text":"<p>Convert the device geometry to a gdsfactory Component.</p> <p>Returns:</p> Type Description <code>Component</code> <p>A gdsfactory Component object representing the device geometry.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the gdsfactory package is not installed.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdsfactory(self) -&gt; \"gf.Component\":  # noqa: F821\n    \"\"\"\n    Convert the device geometry to a gdsfactory Component.\n\n    Returns\n    -------\n    gf.Component\n        A gdsfactory Component object representing the device geometry.\n\n    Raises\n    ------\n    ImportError\n        If the gdsfactory package is not installed.\n    \"\"\"\n    try:\n        import gdsfactory as gf\n    except ImportError:\n        raise ImportError(\n            \"The gdsfactory package is required to use this function; \"\n            \"try `pip install gdsfactory`.\"\n        ) from None\n\n    device_array = np.rot90(self.to_ndarray(), k=-1)\n    return gf.read.from_np(device_array, nm_per_pixel=1)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_gdstk","title":"<code>to_gdstk(cell_name='prefab_device', gds_layer=(1, 0), contour_approx_mode=2)</code>","text":"<p>Converts the device geometry to a GDSTK cell object.</p> <p>This method prepares the device geometry for GDSII file export by converting it into a GDSTK cell object. GDSTK is a Python module for creating and manipulating GDSII layout files. The conversion involves contour approximation to simplify the geometry while preserving essential features.</p> <p>Parameters:</p> Name Type Description Default <code>cell_name</code> <code>str</code> <p>The name of the cell to be created. Defaults to \"prefab_device\".</p> <code>'prefab_device'</code> <code>gds_layer</code> <code>tuple[int, int]</code> <p>The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>contour_approx_mode</code> <code>int</code> <p>The mode of contour approximation used during the conversion. Defaults to 2, which corresponds to <code>cv2.CHAIN_APPROX_SIMPLE</code>, a method that compresses horizontal, vertical, and diagonal segments and leaves only their endpoints.</p> <code>2</code> <p>Returns:</p> Type Description <code>Cell</code> <p>The GDSTK cell object representing the device geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_gdstk(\n    self,\n    cell_name: str = \"prefab_device\",\n    gds_layer: tuple[int, int] = (1, 0),\n    contour_approx_mode: int = 2,\n):\n    \"\"\"\n    Converts the device geometry to a GDSTK cell object.\n\n    This method prepares the device geometry for GDSII file export by converting it\n    into a GDSTK cell object. GDSTK is a Python module for creating and manipulating\n    GDSII layout files. The conversion involves contour approximation to simplify\n    the geometry while preserving essential features.\n\n    Parameters\n    ----------\n    cell_name : str, optional\n        The name of the cell to be created. Defaults to \"prefab_device\".\n    gds_layer : tuple[int, int], optional\n        The layer and datatype to use within the GDSTK cell. Defaults to (1, 0).\n    contour_approx_mode : int, optional\n        The mode of contour approximation used during the conversion. Defaults to 2,\n        which corresponds to `cv2.CHAIN_APPROX_SIMPLE`, a method that compresses\n        horizontal, vertical, and diagonal segments and leaves only their endpoints.\n\n    Returns\n    -------\n    gdstk.Cell\n        The GDSTK cell object representing the device geometry.\n    \"\"\"\n    print(f\"Creating cell '{cell_name}'...\")\n    gdstk_cell = self.flatten()._device_to_gdstk(\n        cell_name=cell_name,\n        gds_layer=gds_layer,\n        contour_approx_mode=contour_approx_mode,\n    )\n    return gdstk_cell\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_img","title":"<code>to_img(img_path='prefab_device.png')</code>","text":"<p>Exports the device geometry as an image file.</p> <p>This method converts the device geometry to an ndarray using <code>to_ndarray</code>, scales the values to the range [0, 255] for image representation, and saves the result as an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path where the image file will be saved. If not specified, the image is saved as \"prefab_device.png\" in the current directory.</p> <code>'prefab_device.png'</code> Source code in <code>prefab/device.py</code> <pre><code>def to_img(self, img_path: str = \"prefab_device.png\"):\n    \"\"\"\n    Exports the device geometry as an image file.\n\n    This method converts the device geometry to an ndarray using `to_ndarray`,\n    scales the values to the range [0, 255] for image representation, and saves the\n    result as an image file.\n\n    Parameters\n    ----------\n    img_path : str, optional\n        The path where the image file will be saved. If not specified, the image is\n        saved as \"prefab_device.png\" in the current directory.\n    \"\"\"\n    cv2.imwrite(img_path, 255 * self.flatten().to_ndarray())\n    print(f\"Saved Device to '{img_path}'\")\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_ndarray","title":"<code>to_ndarray()</code>","text":"<p>Converts the device geometry to an ndarray.</p> <p>This method applies the buffer specifications to crop the device array if necessary, based on the buffer mode ('edge' or 'constant'). It then returns the resulting ndarray representing the device geometry.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ndarray representation of the device geometry, with any applied buffer cropping.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_ndarray(self) -&gt; np.ndarray:\n    \"\"\"\n    Converts the device geometry to an ndarray.\n\n    This method applies the buffer specifications to crop the device array if\n    necessary, based on the buffer mode ('edge' or 'constant'). It then returns the\n    resulting ndarray representing the device geometry.\n\n    Returns\n    -------\n    np.ndarray\n        The ndarray representation of the device geometry, with any applied buffer\n        cropping.\n    \"\"\"\n    device_array = np.copy(self.device_array)\n    buffer_thickness = self.buffer_spec.thickness\n    buffer_mode = self.buffer_spec.mode\n\n    crop_top = buffer_thickness[\"top\"] if buffer_mode[\"top\"] == \"edge\" else 0\n    crop_bottom = (\n        buffer_thickness[\"bottom\"] if buffer_mode[\"bottom\"] == \"edge\" else 0\n    )\n    crop_left = buffer_thickness[\"left\"] if buffer_mode[\"left\"] == \"edge\" else 0\n    crop_right = buffer_thickness[\"right\"] if buffer_mode[\"right\"] == \"edge\" else 0\n\n    ndarray = device_array[\n        crop_top : device_array.shape[0] - crop_bottom,\n        crop_left : device_array.shape[1] - crop_right,\n    ]\n    return np.squeeze(ndarray)\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_stl","title":"<code>to_stl(thickness_nm, filename='prefab_device.stl')</code>","text":"<p>Export the device geometry as an STL file.</p> <p>Parameters:</p> Name Type Description Default <code>thickness_nm</code> <code>int</code> <p>The thickness of the 3D representation in nanometers.</p> required <code>filename</code> <code>str</code> <p>The name of the STL file to save. Defaults to \"prefab_device.stl\".</p> <code>'prefab_device.stl'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the thickness is not a positive integer.</p> <code>ImportError</code> <p>If the numpy-stl package is not installed.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_stl(self, thickness_nm: int, filename: str = \"prefab_device.stl\"):\n    \"\"\"\n    Export the device geometry as an STL file.\n\n    Parameters\n    ----------\n    thickness_nm : int\n        The thickness of the 3D representation in nanometers.\n    filename : str, optional\n        The name of the STL file to save. Defaults to \"prefab_device.stl\".\n\n    Raises\n    ------\n    ValueError\n        If the thickness is not a positive integer.\n    ImportError\n        If the numpy-stl package is not installed.\n    \"\"\"\n    try:\n        from stl import mesh\n    except ImportError:\n        raise ImportError(\n            \"The stl package is required to use this function; \"\n            \"try `pip install numpy-stl`.\"\n        ) from None\n\n    if thickness_nm &lt;= 0:\n        raise ValueError(\"Thickness must be a positive integer.\")\n\n    layered_array = self.to_3d(thickness_nm)\n    layered_array = np.pad(\n        layered_array, ((0, 0), (0, 0), (10, 10)), mode=\"constant\"\n    )\n    verts, faces, _, _ = measure.marching_cubes(layered_array, level=0.5)\n    cube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))\n    for i, f in enumerate(faces):\n        for j in range(3):\n            cube.vectors[i][j] = verts[f[j], :]\n    cube.save(filename)\n    print(f\"Saved Device to '{filename}'\")\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.to_tidy3d","title":"<code>to_tidy3d(eps0, thickness)</code>","text":"<p>Convert the device geometry to a Tidy3D Structure.</p> <p>Parameters:</p> Name Type Description Default <code>eps0</code> <code>float</code> <p>The permittivity value to assign to the device array.</p> required <code>thickness</code> <code>float</code> <p>The thickness of the device in the z-direction.</p> required <p>Returns:</p> Type Description <code>Structure</code> <p>A Tidy3D Structure object representing the device geometry.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the tidy3d package is not installed.</p> Source code in <code>prefab/device.py</code> <pre><code>def to_tidy3d(\n    self,\n    eps0: float,\n    thickness: float,\n) -&gt; \"td.Structure\":  # noqa: F821\n    \"\"\"\n    Convert the device geometry to a Tidy3D Structure.\n\n    Parameters\n    ----------\n    eps0 : float\n        The permittivity value to assign to the device array.\n    thickness : float\n        The thickness of the device in the z-direction.\n\n    Returns\n    -------\n    td.Structure\n        A Tidy3D Structure object representing the device geometry.\n\n    Raises\n    ------\n    ImportError\n        If the tidy3d package is not installed.\n    \"\"\"\n    try:\n        from tidy3d import Box, CustomMedium, SpatialDataArray, Structure, inf\n    except ImportError:\n        raise ImportError(\n            \"The tidy3d package is required to use this function; \"\n            \"try `pip install tidy3d`.\"\n        ) from None\n\n    X = np.linspace(-self.shape[1] / 2000, self.shape[1] / 2000, self.shape[1])\n    Y = np.linspace(-self.shape[0] / 2000, self.shape[0] / 2000, self.shape[0])\n    Z = np.array([0])\n\n    device_array = np.rot90(np.fliplr(self.device_array), k=1)\n    eps_array = np.where(device_array &gt;= 1.0, eps0, device_array)\n    eps_array = np.where(eps_array &lt; 1.0, 1.0, eps_array)\n    eps_dataset = SpatialDataArray(eps_array, coords=dict(x=X, y=Y, z=Z))\n    medium = CustomMedium.from_eps_raw(eps_dataset)\n    return Structure(\n        geometry=Box(center=(0, 0, 0), size=(inf, inf, thickness)), medium=medium\n    )\n</code></pre>"},{"location":"reference/device/#prefab.device.Device.trim","title":"<code>trim()</code>","text":"<p>Trim the device geometry by removing empty space around it.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_thickness</code> <code>dict</code> <p>A dictionary specifying the thickness of the buffer to leave around the non-zero elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'. Defaults to None, which means no buffer is added.</p> required <p>Returns:</p> Type Description <code>Device</code> <p>A new instance of the Device with the trimmed geometry.</p> Source code in <code>prefab/device.py</code> <pre><code>def trim(self) -&gt; \"Device\":\n    \"\"\"\n    Trim the device geometry by removing empty space around it.\n\n    Parameters\n    ----------\n    buffer_thickness : dict, optional\n        A dictionary specifying the thickness of the buffer to leave around the\n        non-zero elements of the array. Should contain keys 'top', 'bottom', 'left',\n        'right'. Defaults to None, which means no buffer is added.\n\n    Returns\n    -------\n    Device\n        A new instance of the Device with the trimmed geometry.\n    \"\"\"\n    trimmed_device_array = geometry.trim(\n        device_array=self.device_array,\n        buffer_thickness=self.buffer_spec.thickness,\n    )\n    return self.model_copy(update={\"device_array\": trimmed_device_array})\n</code></pre>"},{"location":"reference/geometry/","title":"Geometry","text":"<p>Provides functions for manipulating ndarrays of device geometries.</p>"},{"location":"reference/geometry/#prefab.geometry.binarize","title":"<code>binarize(device_array, eta=0.5, beta=np.inf)</code>","text":"<p>Binarize the input ndarray based on a threshold and a scaling factor.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <code>beta</code> <code>float</code> <p>The scaling factor for the binarization process. A higher value makes the transition sharper. Defaults to np.inf, which results in a hard threshold.</p> <code>inf</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize(\n    device_array: np.ndarray, eta: float = 0.5, beta: float = np.inf\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input ndarray based on a threshold and a scaling factor.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n    beta : float, optional\n        The scaling factor for the binarization process. A higher value makes the\n        transition sharper. Defaults to np.inf, which results in a hard threshold.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements scaled to 0 or 1.\n    \"\"\"\n    return (np.tanh(beta * eta) + np.tanh(beta * (device_array - eta))) / (\n        np.tanh(beta * eta) + np.tanh(beta * (1 - eta))\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_hard","title":"<code>binarize_hard(device_array, eta=0.5)</code>","text":"<p>Apply a hard threshold to binarize the input ndarray. The <code>binarize</code> function is generally preferred for most use cases, but it can create numerical artifacts for large beta values.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>eta</code> <code>float</code> <p>The threshold value for binarization. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements set to 0 or 1 based on the threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_hard(device_array: np.ndarray, eta: float = 0.5) -&gt; np.ndarray:\n    \"\"\"\n    Apply a hard threshold to binarize the input ndarray. The `binarize` function is\n    generally preferred for most use cases, but it can create numerical artifacts for\n    large beta values.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    eta : float, optional\n        The threshold value for binarization. Defaults to 0.5.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the threshold.\n    \"\"\"\n    return np.where(device_array &lt; eta, 0.0, 1.0)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_monte_carlo","title":"<code>binarize_monte_carlo(device_array, threshold_noise_std, threshold_blur_std)</code>","text":"<p>Binarize the input ndarray using a Monte Carlo approach with Gaussian blurring.</p> <p>This function applies a dynamic thresholding technique where the threshold value is determined by a base value perturbed by Gaussian-distributed random noise. The threshold is then spatially varied across the array using Gaussian blurring, simulating a potentially more realistic scenario where the threshold is not uniform across the device.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be binarized.</p> required <code>threshold_noise_std</code> <code>float</code> <p>The standard deviation of the Gaussian distribution used to generate noise for the threshold values. This controls the amount of randomness in the threshold.</p> required <code>threshold_blur_std</code> <code>float</code> <p>The standard deviation for the Gaussian kernel used in blurring the threshold map. This controls the spatial variation of the threshold across the array.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized array with elements set to 0 or 1 based on the dynamically generated threshold.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_monte_carlo(\n    device_array: np.ndarray,\n    threshold_noise_std: float,\n    threshold_blur_std: float,\n) -&gt; np.ndarray:\n    \"\"\"\n    Binarize the input ndarray using a Monte Carlo approach with Gaussian blurring.\n\n    This function applies a dynamic thresholding technique where the threshold value is\n    determined by a base value perturbed by Gaussian-distributed random noise. The\n    threshold is then spatially varied across the array using Gaussian blurring,\n    simulating a potentially more realistic scenario where the threshold is not uniform\n    across the device.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be binarized.\n    threshold_noise_std : float\n        The standard deviation of the Gaussian distribution used to generate noise for\n        the threshold values. This controls the amount of randomness in the threshold.\n    threshold_blur_std : float\n        The standard deviation for the Gaussian kernel used in blurring the threshold\n        map. This controls the spatial variation of the threshold across the array.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized array with elements set to 0 or 1 based on the dynamically\n        generated threshold.\n    \"\"\"\n    device_array = np.squeeze(device_array)\n    base_threshold = np.random.normal(loc=0.5, scale=0.1)\n    threshold_noise = np.random.normal(\n        loc=0, scale=threshold_noise_std, size=device_array.shape\n    )\n    spatial_threshold = cv2.GaussianBlur(\n        threshold_noise, ksize=(0, 0), sigmaX=threshold_blur_std\n    )\n    dynamic_threshold = base_threshold + spatial_threshold\n    binarized_array = np.where(device_array &lt; dynamic_threshold, 0.0, 1.0)\n    binarized_array = np.expand_dims(binarized_array, axis=-1)\n    return binarized_array\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.binarize_sem","title":"<code>binarize_sem(sem_array)</code>","text":"<p>Binarize a grayscale scanning electron microscope (SEM) image.</p> <p>This function applies Otsu's method to automatically determine the optimal threshold value for binarization of a grayscale SEM image.</p> <p>Parameters:</p> Name Type Description Default <code>sem_array</code> <code>ndarray</code> <p>The input SEM image array to be binarized.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The binarized SEM image array with elements scaled to 0 or 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def binarize_sem(sem_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Binarize a grayscale scanning electron microscope (SEM) image.\n\n    This function applies Otsu's method to automatically determine the optimal threshold\n    value for binarization of a grayscale SEM image.\n\n    Parameters\n    ----------\n    sem_array : np.ndarray\n        The input SEM image array to be binarized.\n\n    Returns\n    -------\n    np.ndarray\n        The binarized SEM image array with elements scaled to 0 or 1.\n    \"\"\"\n    return cv2.threshold(\n        sem_array.astype(\"uint8\"), 0, 1, cv2.THRESH_BINARY + cv2.THRESH_OTSU\n    )[1]\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.blur","title":"<code>blur(device_array, sigma=1.0)</code>","text":"<p>Apply Gaussian blur to the input ndarray and normalize the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be blurred.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation for the Gaussian kernel. This controls the amount of blurring. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The blurred and normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def blur(device_array: np.ndarray, sigma: float = 1.0) -&gt; np.ndarray:\n    \"\"\"\n    Apply Gaussian blur to the input ndarray and normalize the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be blurred.\n    sigma : float, optional\n        The standard deviation for the Gaussian kernel. This controls the amount of\n        blurring. Defaults to 1.0.\n\n    Returns\n    -------\n    np.ndarray\n        The blurred and normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return np.expand_dims(\n        normalize(cv2.GaussianBlur(device_array, ksize=(0, 0), sigmaX=sigma)), axis=-1\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.dilate","title":"<code>dilate(device_array, kernel_size)</code>","text":"<p>Dilate the input ndarray using a specified kernel size.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry to be dilated.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for dilation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The dilated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def dilate(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Dilate the input ndarray using a specified kernel size.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be dilated.\n    kernel_size : int\n        The size of the kernel used for dilation.\n\n    Returns\n    -------\n    np.ndarray\n        The dilated array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return np.expand_dims(cv2.dilate(device_array, kernel=kernel), axis=-1)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.erode","title":"<code>erode(device_array, kernel_size)</code>","text":"<p>Erode the input ndarray using a specified kernel size and number of iterations.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array representing the device geometry to be eroded.</p> required <code>kernel_size</code> <code>int</code> <p>The size of the kernel used for erosion.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The eroded array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def erode(device_array: np.ndarray, kernel_size: int) -&gt; np.ndarray:\n    \"\"\"\n    Erode the input ndarray using a specified kernel size and number of iterations.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array representing the device geometry to be eroded.\n    kernel_size : int\n        The size of the kernel used for erosion.\n\n    Returns\n    -------\n    np.ndarray\n        The eroded array.\n    \"\"\"\n    kernel = np.ones((kernel_size, kernel_size), dtype=np.uint8)\n    return np.expand_dims(cv2.erode(device_array, kernel=kernel), axis=-1)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.flatten","title":"<code>flatten(device_array)</code>","text":"<p>Flatten the input ndarray by summing the vertical layers and normalizing the result.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be flattened.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The flattened array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def flatten(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Flatten the input ndarray by summing the vertical layers and normalizing the result.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be flattened.\n\n    Returns\n    -------\n    np.ndarray\n        The flattened array with values scaled between 0 and 1.\n    \"\"\"\n    return normalize(np.sum(device_array, axis=-1, keepdims=True))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.normalize","title":"<code>normalize(device_array)</code>","text":"<p>Normalize the input ndarray to have values between 0 and 1.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be normalized.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The normalized array with values scaled between 0 and 1.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def normalize(device_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Normalize the input ndarray to have values between 0 and 1.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be normalized.\n\n    Returns\n    -------\n    np.ndarray\n        The normalized array with values scaled between 0 and 1.\n    \"\"\"\n    return (device_array - np.min(device_array)) / (\n        np.max(device_array) - np.min(device_array)\n    )\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.rotate","title":"<code>rotate(device_array, angle)</code>","text":"<p>Rotate the input ndarray by a given angle.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be rotated.</p> required <code>angle</code> <code>float</code> <p>The angle of rotation in degrees. Positive values mean counter-clockwise rotation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The rotated array.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def rotate(device_array: np.ndarray, angle: float) -&gt; np.ndarray:\n    \"\"\"\n    Rotate the input ndarray by a given angle.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be rotated.\n    angle : float\n        The angle of rotation in degrees. Positive values mean counter-clockwise\n        rotation.\n\n    Returns\n    -------\n    np.ndarray\n        The rotated array.\n    \"\"\"\n    center = (device_array.shape[1] / 2, device_array.shape[0] / 2)\n    rotation_matrix = cv2.getRotationMatrix2D(center=center, angle=angle, scale=1)\n    return np.expand_dims(\n        cv2.warpAffine(\n            device_array,\n            M=rotation_matrix,\n            dsize=(device_array.shape[1], device_array.shape[0]),\n        ),\n        axis=-1,\n    )\n    return np.expand_dims(rotated_device_array, axis=-1)\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.ternarize","title":"<code>ternarize(device_array, eta1=1 / 3, eta2=2 / 3)</code>","text":"<p>Ternarize the input ndarray based on two thresholds. This function is useful for flattened devices with angled sidewalls (i.e., three segments).</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be ternarized.</p> required <code>eta1</code> <code>float</code> <p>The first threshold value for ternarization. Defaults to 1/3.</p> <code>1 / 3</code> <code>eta2</code> <code>float</code> <p>The second threshold value for ternarization. Defaults to 2/3.</p> <code>2 / 3</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def ternarize(\n    device_array: np.ndarray, eta1: float = 1 / 3, eta2: float = 2 / 3\n) -&gt; np.ndarray:\n    \"\"\"\n    Ternarize the input ndarray based on two thresholds. This function is useful for\n    flattened devices with angled sidewalls (i.e., three segments).\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be ternarized.\n    eta1 : float, optional\n        The first threshold value for ternarization. Defaults to 1/3.\n    eta2 : float, optional\n        The second threshold value for ternarization. Defaults to 2/3.\n\n    Returns\n    -------\n    np.ndarray\n        The ternarized array with elements set to 0, 0.5, or 1 based on the thresholds.\n    \"\"\"\n    return np.where(device_array &lt; eta1, 0.0, np.where(device_array &gt;= eta2, 1.0, 0.5))\n</code></pre>"},{"location":"reference/geometry/#prefab.geometry.trim","title":"<code>trim(device_array, buffer_thickness=None)</code>","text":"<p>Trim the input ndarray by removing rows and columns that are completely zero.</p> <p>Parameters:</p> Name Type Description Default <code>device_array</code> <code>ndarray</code> <p>The input array to be trimmed.</p> required <code>buffer_thickness</code> <code>dict</code> <p>A dictionary specifying the thickness of the buffer to leave around the non-zero elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'. Defaults to None, which means no buffer is added.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The trimmed array, potentially with a buffer around the non-zero elements.</p> Source code in <code>prefab/geometry.py</code> <pre><code>def trim(device_array: np.ndarray, buffer_thickness: dict = None) -&gt; np.ndarray:\n    \"\"\"\n    Trim the input ndarray by removing rows and columns that are completely zero.\n\n    Parameters\n    ----------\n    device_array : np.ndarray\n        The input array to be trimmed.\n    buffer_thickness : dict, optional\n        A dictionary specifying the thickness of the buffer to leave around the non-zero\n        elements of the array. Should contain keys 'top', 'bottom', 'left', 'right'.\n        Defaults to None, which means no buffer is added.\n\n    Returns\n    -------\n    np.ndarray\n        The trimmed array, potentially with a buffer around the non-zero elements.\n    \"\"\"\n    if buffer_thickness is None:\n        buffer_thickness = {\"top\": 0, \"bottom\": 0, \"left\": 0, \"right\": 0}\n\n    nonzero_rows, nonzero_cols = np.nonzero(np.squeeze(device_array))\n    row_min = max(nonzero_rows.min() - buffer_thickness.get(\"top\", 0), 0)\n    row_max = min(\n        nonzero_rows.max() + buffer_thickness.get(\"bottom\", 0) + 1,\n        device_array.shape[0],\n    )\n    col_min = max(nonzero_cols.min() - buffer_thickness.get(\"left\", 0), 0)\n    col_max = min(\n        nonzero_cols.max() + buffer_thickness.get(\"right\", 0) + 1,\n        device_array.shape[1],\n    )\n    return device_array[\n        row_min:row_max,\n        col_min:col_max,\n    ]\n</code></pre>"},{"location":"reference/models/","title":"Models","text":"<p>Models for the PreFab library.</p>"},{"location":"reference/models/#prefab.models.Fab","title":"<code>Fab</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a fabrication process in the PreFab model library.</p> <p>Parameters:</p> Name Type Description Default <code>foundry</code> <code>str</code> <p>The name of the foundry where the fabrication process takes place.</p> required <code>process</code> <code>str</code> <p>The specific process used in the fabrication.</p> required <code>material</code> <code>str</code> <p>The material used in the fabrication process.</p> required <code>technology</code> <code>str</code> <p>The technology used in the fabrication process.</p> required <code>thickness</code> <code>int</code> <p>The thickness of the material used, measured in nanometers.</p> required <code>has_sidewall</code> <code>bool</code> <p>Indicates whether the fabrication has angled sidewalls.</p> required Source code in <code>prefab/models.py</code> <pre><code>class Fab(BaseModel):\n    \"\"\"\n    Represents a fabrication process in the PreFab model library.\n\n    Parameters\n    ----------\n    foundry : str\n        The name of the foundry where the fabrication process takes place.\n    process : str\n        The specific process used in the fabrication.\n    material : str\n        The material used in the fabrication process.\n    technology : str\n        The technology used in the fabrication process.\n    thickness : int\n        The thickness of the material used, measured in nanometers.\n    has_sidewall : bool\n        Indicates whether the fabrication has angled sidewalls.\n    \"\"\"\n\n    foundry: str\n    process: str\n    material: str\n    technology: str\n    thickness: int\n    has_sidewall: bool\n</code></pre>"},{"location":"reference/models/#prefab.models.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a model of a fabrication process including versioning and dataset detail.</p> <p>Attributes:</p> Name Type Description <code>fab</code> <code>Fab</code> <p>An instance of the Fab class representing the fabrication details.</p> <code>version</code> <code>str</code> <p>The version identifier of the model.</p> <code>version_date</code> <code>date</code> <p>The release date of this version of the model.</p> <code>dataset</code> <code>str</code> <p>The identifier for the dataset used in this model.</p> <code>dataset_date</code> <code>date</code> <p>The date when the dataset was last updated or released.</p> <code>tag</code> <code>str</code> <p>An optional tag for additional categorization or notes.</p> <p>Methods:</p> Name Description <code>to_json</code> <p>Serializes the model instance to a JSON formatted string.</p> Source code in <code>prefab/models.py</code> <pre><code>class Model(BaseModel):\n    \"\"\"\n    Represents a model of a fabrication process including versioning and dataset detail.\n\n    Attributes\n    ----------\n    fab : Fab\n        An instance of the Fab class representing the fabrication details.\n    version : str\n        The version identifier of the model.\n    version_date : date\n        The release date of this version of the model.\n    dataset : str\n        The identifier for the dataset used in this model.\n    dataset_date : date\n        The date when the dataset was last updated or released.\n    tag : str\n        An optional tag for additional categorization or notes.\n\n    Methods\n    -------\n    to_json()\n        Serializes the model instance to a JSON formatted string.\n    \"\"\"\n\n    fab: Fab\n    version: str\n    version_date: date\n    dataset: str\n    dataset_date: date\n    tag: str\n\n    def to_json(self):\n        return json.dumps(self.dict(), default=str)\n</code></pre>"},{"location":"reference/read/","title":"Read","text":"<p>Provides functions to create a Device from various data sources.</p>"},{"location":"reference/read/#prefab.read.from_gds","title":"<code>from_gds(gds_path, cell_name, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a GDS cell.</p> <p>Parameters:</p> Name Type Description Default <code>gds_path</code> <code>str</code> <p>The file path to the GDS file.</p> required <code>cell_name</code> <code>str</code> <p>The name of the cell within the GDS file to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the GDS file. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>tuple[tuple[int, int], tuple[int, int]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the specified cell from the GDS file, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gds(\n    gds_path: str,\n    cell_name: str,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a GDS cell.\n\n    Parameters\n    ----------\n    gds_path : str\n        The file path to the GDS file.\n    cell_name : str\n        The name of the cell within the GDS file to be converted into a Device object.\n    gds_layer : tuple[int, int], optional\n        A tuple specifying the layer and datatype to be used from the GDS file. Defaults\n        to (1, 0).\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the specified cell from the GDS file, after\n        processing based on the specified layer.\n    \"\"\"\n    gdstk_library = gdstk.read_gds(gds_path)\n    gdstk_cell = gdstk_library[cell_name]\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_gdsfactory","title":"<code>from_gdsfactory(component, **kwargs)</code>","text":"<p>Create a Device from a gdsfactory component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The gdsfactory component to be converted into a Device object.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the gdsfactory component.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the gdsfactory package is not installed.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdsfactory(\n    component: \"gf.Component\",  # noqa: F821\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a gdsfactory component.\n\n    Parameters\n    ----------\n    component : gf.Component\n        The gdsfactory component to be converted into a Device object.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdsfactory component.\n\n    Raises\n    ------\n    ImportError\n        If the gdsfactory package is not installed.\n    \"\"\"\n    try:\n        import gdsfactory as gf\n    except ImportError:\n        raise ImportError(\n            \"The gdsfactory package is required to use this function; \"\n            \"try `pip install gdsfactory`.\"\n        ) from None\n\n    bounds = (\n        (component.xmin * 1000, component.ymin * 1000),\n        (component.xmax * 1000, component.ymax * 1000),\n    )\n\n    polygons = [\n        polygon\n        for polygons_list in component.get_polygons_points().values()\n        for polygon in polygons_list\n    ]\n\n    contours = [\n        np.array(\n            [\n                [\n                    [\n                        int(1000 * vertex[0] - bounds[0][0]),\n                        int(1000 * vertex[1] - bounds[0][1]),\n                    ]\n                ]\n                for vertex in polygon\n            ]\n        )\n        for polygon in polygons\n    ]\n\n    device_array = np.zeros(\n        (int(bounds[1][1] - bounds[0][1]), int(bounds[1][0] - bounds[0][0])),\n        dtype=np.uint8,\n    )\n    cv2.fillPoly(img=device_array, pts=contours, color=(1, 1, 1))\n    device_array = np.flipud(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_gdstk","title":"<code>from_gdstk(gdstk_cell, gds_layer=(1, 0), bounds=None, **kwargs)</code>","text":"<p>Create a Device from a gdstk cell.</p> <p>Parameters:</p> Name Type Description Default <code>gdstk_cell</code> <code>Cell</code> <p>The gdstk.Cell object to be converted into a Device object.</p> required <code>gds_layer</code> <code>tuple[int, int]</code> <p>A tuple specifying the layer and datatype to be used from the cell. Defaults to (1, 0).</p> <code>(1, 0)</code> <code>bounds</code> <code>tuple[tuple[int, int], tuple[int, int]]</code> <p>A tuple specifying the bounds for cropping the cell before conversion, formatted as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the entire cell is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the gdstk.Cell, after processing based on the specified layer.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_gdstk(\n    gdstk_cell: gdstk.Cell,\n    gds_layer: tuple[int, int] = (1, 0),\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Create a Device from a gdstk cell.\n\n    Parameters\n    ----------\n    gdstk_cell : gdstk.Cell\n        The gdstk.Cell object to be converted into a Device object.\n    gds_layer : tuple[int, int], optional\n        A tuple specifying the layer and datatype to be used from the cell. Defaults to\n        (1, 0).\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the cell before conversion, formatted\n        as ((min_x, min_y), (max_x, max_y)), in units of the GDS file. If None, the\n        entire cell is used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the gdstk.Cell, after processing based on the\n        specified layer.\n    \"\"\"\n    device_array = _gdstk_to_device_array(\n        gdstk_cell=gdstk_cell, gds_layer=gds_layer, bounds=bounds\n    )\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_img","title":"<code>from_img(img_path, img_width_nm=None, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an image file.</p> <p>Parameters:</p> Name Type Description Default <code>img_path</code> <code>str</code> <p>The path to the image file to be converted into a Device object.</p> required <code>img_width_nm</code> <code>int</code> <p>The width of the image in nanometers. If specified, the Device will be resized to this width while maintaining aspect ratio. If None, no resizing is performed.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the image will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale images into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed image, after optional resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_img(\n    img_path: str, img_width_nm: int = None, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an image file.\n\n    Parameters\n    ----------\n    img_path : str\n        The path to the image file to be converted into a Device object.\n    img_width_nm : int, optional\n        The width of the image in nanometers. If specified, the Device will be resized\n        to this width while maintaining aspect ratio. If None, no resizing is performed.\n    binarize : bool, optional\n        If True, the image will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale images\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed image, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = cv2.imread(img_path, flags=cv2.IMREAD_GRAYSCALE) / 255\n    if img_width_nm is not None:\n        resolution = img_width_nm / device_array.shape[1]\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=resolution, fy=resolution\n        )\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_ndarray","title":"<code>from_ndarray(ndarray, resolution=1.0, binarize=True, **kwargs)</code>","text":"<p>Create a Device from an ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <code>ndarray</code> <p>The input array representing the device layout.</p> required <code>resolution</code> <code>float</code> <p>The resolution of the ndarray in nanometers per pixel, defaulting to 1.0 nm per pixel. If specified, the input array will be resized based on this resolution to match the desired physical size.</p> <code>1.0</code> <code>binarize</code> <code>bool</code> <p>If True, the input array will be binarized (converted to binary values) before conversion to a Device object. This is useful for processing grayscale arrays into binary masks. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the input array, after optional resizing and binarization.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_ndarray(\n    ndarray: np.ndarray, resolution: float = 1.0, binarize: bool = True, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device from an ndarray.\n\n    Parameters\n    ----------\n    ndarray : np.ndarray\n        The input array representing the device layout.\n    resolution : float, optional\n        The resolution of the ndarray in nanometers per pixel, defaulting to 1.0 nm per\n        pixel. If specified, the input array will be resized based on this resolution to\n        match the desired physical size.\n    binarize : bool, optional\n        If True, the input array will be binarized (converted to binary values) before\n        conversion to a Device object. This is useful for processing grayscale arrays\n        into binary masks. Defaults to True.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the input array, after optional resizing and\n        binarization.\n    \"\"\"\n    device_array = ndarray\n    if resolution != 1.0:\n        device_array = cv2.resize(\n            device_array, dsize=(0, 0), fx=resolution, fy=resolution\n        )\n    if binarize:\n        device_array = geometry.binarize_hard(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_sem","title":"<code>from_sem(sem_path, sem_resolution=None, sem_resolution_key=None, binarize=False, bounds=None, **kwargs)</code>","text":"<p>Create a Device from a scanning electron microscope (SEM) image file.</p> <p>Parameters:</p> Name Type Description Default <code>sem_path</code> <code>str</code> <p>The file path to the SEM image.</p> required <code>sem_resolution</code> <code>float</code> <p>The resolution of the SEM image in nanometers per pixel. If not provided, it will be extracted from the image metadata using the <code>sem_resolution_key</code>.</p> <code>None</code> <code>sem_resolution_key</code> <code>str</code> <p>The key to look for in the SEM image metadata to extract the resolution. Required if <code>sem_resolution</code> is not provided.</p> <code>None</code> <code>binarize</code> <code>bool</code> <p>If True, the SEM image will be binarized (converted to binary values) before conversion to a Device object. This is needed for processing grayscale images into binary masks. Defaults to False.</p> <code>False</code> <code>bounds</code> <code>tuple[tuple[int, int], tuple[int, int]]</code> <p>A tuple specifying the bounds for cropping the image before conversion, formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the processed SEM image.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>sem_resolution</code> nor <code>sem_resolution_key</code> is provided.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_sem(\n    sem_path: str,\n    sem_resolution: float = None,\n    sem_resolution_key: str = None,\n    binarize: bool = False,\n    bounds: tuple[tuple[int, int], tuple[int, int]] = None,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a scanning electron microscope (SEM) image file.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution : float, optional\n        The resolution of the SEM image in nanometers per pixel. If not provided, it\n        will be extracted from the image metadata using the `sem_resolution_key`.\n    sem_resolution_key : str, optional\n        The key to look for in the SEM image metadata to extract the resolution.\n        Required if `sem_resolution` is not provided.\n    binarize : bool, optional\n        If True, the SEM image will be binarized (converted to binary values) before\n        conversion to a Device object. This is needed for processing grayscale images\n        into binary masks. Defaults to False.\n    bounds : tuple[tuple[int, int], tuple[int, int]], optional\n        A tuple specifying the bounds for cropping the image before conversion,\n        formatted as ((min_x, min_y), (max_x, max_y)). If None, the entire image is\n        used.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the processed SEM image.\n\n    Raises\n    ------\n    ValueError\n        If neither `sem_resolution` nor `sem_resolution_key` is provided.\n    \"\"\"\n    if sem_resolution is None and sem_resolution_key is not None:\n        sem_resolution = get_sem_resolution(sem_path, sem_resolution_key)\n    elif sem_resolution is None:\n        raise ValueError(\"Either sem_resolution or resolution_key must be provided.\")\n\n    device_array = cv2.imread(sem_path, flags=cv2.IMREAD_GRAYSCALE)\n    device_array = cv2.resize(\n        device_array, dsize=(0, 0), fx=sem_resolution, fy=sem_resolution\n    )\n    if bounds is not None:\n        device_array = device_array[\n            device_array.shape[0] - bounds[1][1] : device_array.shape[0] - bounds[0][1],\n            bounds[0][0] : bounds[1][0],\n        ]\n    if binarize:\n        device_array = geometry.binarize_sem(device_array)\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.from_tidy3d","title":"<code>from_tidy3d(tidy3d_sim, eps_threshold, z, **kwargs)</code>","text":"<p>Create a Device from a Tidy3D simulation.</p> <p>Parameters:</p> Name Type Description Default <code>tidy3d_sim</code> <code>Simulation</code> <p>The Tidy3D simulation object.</p> required <code>eps_threshold</code> <code>float</code> <p>The threshold value for the permittivity to binarize the device array.</p> required <code>z</code> <code>float</code> <p>The z-coordinate at which to extract the permittivity.</p> required <code>**kwargs</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object representing the permittivity cross-section at the specified z-coordinate for the Tidy3D simulation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the z-coordinate is outside the bounds of the simulation size in the z-direction.</p> <code>ImportError</code> <p>If the tidy3d package is not installed.</p> Source code in <code>prefab/read.py</code> <pre><code>def from_tidy3d(\n    tidy3d_sim: \"tidy3d.Simulation\",  # noqa: F821\n    eps_threshold: float,\n    z: float,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device from a Tidy3D simulation.\n\n    Parameters\n    ----------\n    tidy3d_sim : tidy3d.Simulation\n        The Tidy3D simulation object.\n    eps_threshold : float\n        The threshold value for the permittivity to binarize the device array.\n    z : float\n        The z-coordinate at which to extract the permittivity.\n    **kwargs\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object representing the permittivity cross-section at the specified\n        z-coordinate for the Tidy3D simulation.\n\n    Raises\n    ------\n    ValueError\n        If the z-coordinate is outside the bounds of the simulation size in the\n        z-direction.\n    ImportError\n        If the tidy3d package is not installed.\n    \"\"\"\n    try:\n        from tidy3d import Coords, Grid\n    except ImportError:\n        raise ImportError(\n            \"The tidy3d package is required to use this function; \"\n            \"try `pip install tidy3d`.\"\n        ) from None\n\n    if not (\n        tidy3d_sim.center[2] - tidy3d_sim.size[2] / 2\n        &lt;= z\n        &lt;= tidy3d_sim.center[2] + tidy3d_sim.size[2] / 2\n    ):\n        raise ValueError(\n            f\"z={z} is outside the bounds of the simulation size in the z-direction.\"\n        )\n\n    x = np.arange(\n        tidy3d_sim.center[0] - tidy3d_sim.size[0] / 2,\n        tidy3d_sim.center[0] + tidy3d_sim.size[0] / 2,\n        0.001,\n    )\n    y = np.arange(\n        tidy3d_sim.center[1] - tidy3d_sim.size[1] / 2,\n        tidy3d_sim.center[1] + tidy3d_sim.size[1] / 2,\n        0.001,\n    )\n    z = np.array([z])\n\n    grid = Grid(boundaries=Coords(x=x, y=y, z=z))\n    eps = np.real(tidy3d_sim.epsilon_on_grid(grid=grid, coord_key=\"boundaries\").values)\n    device_array = geometry.binarize_hard(device_array=eps, eta=eps_threshold)[:, :, 0]\n    device_array = np.fliplr(np.rot90(device_array, k=-1))\n    return Device(device_array=device_array, **kwargs)\n</code></pre>"},{"location":"reference/read/#prefab.read.get_sem_resolution","title":"<code>get_sem_resolution(sem_path, sem_resolution_key)</code>","text":"<p>Extracts the resolution of a scanning electron microscope (SEM) image from its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>sem_path</code> <code>str</code> <p>The file path to the SEM image.</p> required <code>sem_resolution_key</code> <code>str</code> <p>The key to look for in the SEM image metadata to extract the resolution.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The resolution of the SEM image in nanometers per pixel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the resolution key is not found in the SEM image metadata.</p> Source code in <code>prefab/read.py</code> <pre><code>def get_sem_resolution(sem_path: str, sem_resolution_key: str) -&gt; float:\n    \"\"\"\n    Extracts the resolution of a scanning electron microscope (SEM) image from its\n    metadata.\n\n    Parameters\n    ----------\n    sem_path : str\n        The file path to the SEM image.\n    sem_resolution_key : str\n        The key to look for in the SEM image metadata to extract the resolution.\n\n    Returns\n    -------\n    float\n        The resolution of the SEM image in nanometers per pixel.\n\n    Raises\n    ------\n    ValueError\n        If the resolution key is not found in the SEM image metadata.\n    \"\"\"\n    with open(sem_path, \"rb\") as file:\n        resolution_key_bytes = sem_resolution_key.encode(\"utf-8\")\n        for line in file:\n            if resolution_key_bytes in line:\n                line_str = line.decode(\"utf-8\")\n                match = re.search(r\"-?\\d+(\\.\\d+)?\", line_str)\n                if match:\n                    value = float(match.group())\n                    if value &gt; 100:\n                        value /= 1000\n                    return value\n    raise ValueError(f\"Resolution key '{sem_resolution_key}' not found in {sem_path}.\")\n</code></pre>"},{"location":"reference/shapes/","title":"Shapes","text":"<p>Contains functions for creating various shapes as Device objects.</p>"},{"location":"reference/shapes/#prefab.shapes.L_grating","title":"<code>L_grating(height=200, pitch=100, duty_cycle=0.5, **kwargs)</code>","text":"<p>Create a Device object with an L-shaped grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height and width of the L-grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the L-shapes. Defaults to 100.</p> <code>100</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the L-shapes. Defaults to 0.5.</p> <code>0.5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the L-shaped grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def L_grating(\n    height: int = 200,\n    pitch: int = 100,\n    duty_cycle: float = 0.5,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an L-shaped grating pattern.\n\n    Parameters\n    ----------\n    height : int, optional\n        The height and width of the L-grating. Defaults to 200.\n    pitch : int, optional\n        The pitch (period) of the L-shapes. Defaults to 100.\n    duty_cycle : float, optional\n        The duty cycle of the L-shapes. Defaults to 0.5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the L-shaped grating pattern.\n    \"\"\"\n    L_grating = np.zeros((height, height))\n    num_L_shapes = height // pitch\n    L_width = int(pitch * duty_cycle)\n    for i in range(num_L_shapes):\n        start = i * pitch\n        L_grating[start : start + L_width, start:] = 1\n        L_grating[start:, start : start + L_width] = 1\n    return Device(device_array=L_grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.box","title":"<code>box(width=200, **kwargs)</code>","text":"<p>Create a Device object with a square box shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width and height of the square box. Defaults to 200.</p> <code>200</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the square box shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def box(width: int = 200, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a square box shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The width and height of the square box. Defaults to 200.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the square box shape.\n    \"\"\"\n    box = np.zeros((width, width))\n    box[:, :] = 1\n    return Device(device_array=box, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.circle","title":"<code>circle(width=200, **kwargs)</code>","text":"<p>Create a Device object with a circular shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width and height of the circle. Defaults to 200.</p> <code>200</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the circular shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def circle(width: int = 200, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a circular shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The width and height of the circle. Defaults to 200.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the circular shape.\n    \"\"\"\n    radius = width // 2\n    y, x = np.ogrid[-radius:radius, -radius:radius]\n    mask = x**2 + y**2 &lt;= radius**2\n    circle = np.zeros((width, width))\n    circle[mask] = 1\n    return Device(device_array=circle, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.circle_wavy","title":"<code>circle_wavy(width=200, wave_amplitude=10, wave_frequency=10, **kwargs)</code>","text":"<p>Create a Device object with a circular shape with wavy edges.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the wavy circle. Defaults to 200.</p> <code>200</code> <code>wave_amplitude</code> <code>float</code> <p>The amplitude of the waves. Defaults to 10.</p> <code>10</code> <code>wave_frequency</code> <code>float</code> <p>The frequency of the waves. Defaults to 10.</p> <code>10</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the wavy circular shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def circle_wavy(\n    width: int = 200, wave_amplitude: float = 10, wave_frequency: float = 10, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a circular shape with wavy edges.\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the wavy circle. Defaults to 200.\n    wave_amplitude : float, optional\n        The amplitude of the waves. Defaults to 10.\n    wave_frequency : float, optional\n        The frequency of the waves. Defaults to 10.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the wavy circular shape.\n    \"\"\"\n    effective_radius = (width // 2) - wave_amplitude\n    y, x = np.ogrid[-width // 2 : width // 2, -width // 2 : width // 2]\n    distance_from_center = np.sqrt(x**2 + y**2)\n    sinusoidal_boundary = effective_radius + wave_amplitude * np.sin(\n        wave_frequency * np.arctan2(y, x)\n    )\n    mask = distance_from_center &lt;= sinusoidal_boundary\n    circle_wavy = np.zeros((width, width))\n    circle_wavy[mask] = 1\n    return Device(device_array=circle_wavy, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.circles","title":"<code>circles(rows=5, cols=5, radius=30, spacing=60, **kwargs)</code>","text":"<p>Create a Device object with a grid of uniform circles.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>radius</code> <code>int</code> <p>The radius of each circle. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between circle centers. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circles.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def circles(\n    rows: int = 5, cols: int = 5, radius: int = 30, spacing: int = 60, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of uniform circles.\n\n    Parameters\n    ----------\n    rows : int, optional\n        The number of rows in the grid. Defaults to 5.\n    cols : int, optional\n        The number of columns in the grid. Defaults to 5.\n    radius : int, optional\n        The radius of each circle. Defaults to 30.\n    spacing : int, optional\n        The spacing between circle centers. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circles.\n    \"\"\"\n    grid_height = rows * (2 * radius + spacing) - spacing\n    grid_width = cols * (2 * radius + spacing) - spacing\n    circles = np.zeros((grid_height, grid_width))\n    y, x = np.ogrid[-radius:radius, -radius:radius]\n    mask = x**2 + y**2 &lt;= radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * radius + spacing) + radius\n            center_x = col * (2 * radius + spacing) + radius\n            circles[\n                center_y - radius : center_y + radius,\n                center_x - radius : center_x + radius,\n            ][mask] = 1\n    return Device(device_array=circles, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.circles_offset","title":"<code>circles_offset(rows=5, cols=5, radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with an offset grid of circles.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>radius</code> <code>int</code> <p>The radius of each circle. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between circle centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing an offset grid of circles.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def circles_offset(\n    rows: int = 5, cols: int = 5, radius: int = 30, spacing: int = 30, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grid of circles.\n\n    Parameters\n    ----------\n    rows : int, optional\n        The number of rows in the grid. Defaults to 5.\n    cols : int, optional\n        The number of columns in the grid. Defaults to 5.\n    radius : int, optional\n        The radius of each circle. Defaults to 30.\n    spacing : int, optional\n        The spacing between circle centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing an offset grid of circles.\n    \"\"\"\n    grid_height = rows * (2 * radius + spacing) - spacing\n    grid_width = cols * (2 * radius + spacing) - spacing + (radius + spacing // 2)\n    circles_offset = np.zeros((grid_height, grid_width))\n    y, x = np.ogrid[-radius:radius, -radius:radius]\n    mask = x**2 + y**2 &lt;= radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * radius + spacing) + radius\n            center_x = (\n                col * (2 * radius + spacing)\n                + radius\n                + (radius + spacing // 2 if row % 2 == 1 else 0)\n            )\n            circles_offset[\n                center_y - radius : center_y + radius,\n                center_x - radius : center_x + radius,\n            ][mask] = 1\n    return Device(device_array=circles_offset, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.circles_varying","title":"<code>circles_varying(rows=5, cols=5, min_radius=10, max_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of circles with varying radii.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>min_radius</code> <code>int</code> <p>The minimum radius of the circles. Defaults to 10.</p> <code>10</code> <code>max_radius</code> <code>int</code> <p>The maximum radius of the circles. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between circle centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circles with varying radii.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def circles_varying(\n    rows: int = 5,\n    cols: int = 5,\n    min_radius: int = 10,\n    max_radius: int = 30,\n    spacing: int = 30,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of circles with varying radii.\n\n    Parameters\n    ----------\n    rows : int, optional\n        The number of rows in the grid. Defaults to 5.\n    cols : int, optional\n        The number of columns in the grid. Defaults to 5.\n    min_radius : int, optional\n        The minimum radius of the circles. Defaults to 10.\n    max_radius : int, optional\n        The maximum radius of the circles. Defaults to 30.\n    spacing : int, optional\n        The spacing between circle centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circles with varying radii.\n    \"\"\"\n    grid_height = rows * (2 * max_radius + spacing) - spacing\n    grid_width = cols * (2 * max_radius + spacing) - spacing\n    circles_varying = np.zeros((grid_height, grid_width))\n    radius_range = np.linspace(min_radius, max_radius, rows * cols).reshape(rows, cols)\n    for row in range(rows):\n        for col in range(cols):\n            radius = int(radius_range[row, col])\n            y, x = np.ogrid[-radius:radius, -radius:radius]\n            mask = x**2 + y**2 &lt;= radius**2\n            center_y = row * (2 * max_radius + spacing) + max_radius\n            center_x = col * (2 * max_radius + spacing) + max_radius\n            circles_varying[\n                center_y - radius : center_y + radius,\n                center_x - radius : center_x + radius,\n            ][mask] = 1\n    return Device(device_array=circles_varying, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.cross","title":"<code>cross(width=200, arm_width=60, **kwargs)</code>","text":"<p>Create a Device object with a cross shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the cross. Defaults to 200.</p> <code>200</code> <code>arm_width</code> <code>int</code> <p>The width of the cross arms. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the cross shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def cross(width: int = 200, arm_width: int = 60, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a cross shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the cross. Defaults to 200.\n    arm_width : int, optional\n        The width of the cross arms. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the cross shape.\n    \"\"\"\n    cross = np.zeros((width, width))\n    center = width // 2\n    half_arm_width = arm_width // 2\n    cross[center - half_arm_width : center + half_arm_width + 1, :] = 1\n    cross[:, center - half_arm_width : center + half_arm_width + 1] = 1\n    return Device(device_array=cross, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.ellipse","title":"<code>ellipse(width=200, height=100, **kwargs)</code>","text":"<p>Create a Device object with an elliptical shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the ellipse. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int</code> <p>The height of the ellipse. Defaults to 100.</p> <code>100</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the elliptical shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def ellipse(width: int = 200, height: int = 100, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with an elliptical shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The width of the ellipse. Defaults to 200.\n    height : int, optional\n        The height of the ellipse. Defaults to 100.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the elliptical shape.\n    \"\"\"\n    y, x = np.ogrid[-height // 2 : height // 2, -width // 2 : width // 2]\n    mask = (x**2 / (width // 2) ** 2) + (y**2 / (height // 2) ** 2) &lt;= 1\n    ellipse = np.zeros((height, width))\n    ellipse[mask] = 1\n    return Device(device_array=ellipse, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.grating","title":"<code>grating(height=200, pitch=120, duty_cycle=0.5, num_gratings=3, **kwargs)</code>","text":"<p>Create a Device object with a grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height of the grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the grating. Defaults to 120.</p> <code>120</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the grating. Defaults to 0.5.</p> <code>0.5</code> <code>num_gratings</code> <code>int</code> <p>The number of grating periods. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def grating(\n    height: int = 200,\n    pitch: int = 120,\n    duty_cycle: float = 0.5,\n    num_gratings: int = 3,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grating pattern.\n\n    Parameters\n    ----------\n    height : int, optional\n        The height of the grating. Defaults to 200.\n    pitch : int, optional\n        The pitch (period) of the grating. Defaults to 120.\n    duty_cycle : float, optional\n        The duty cycle of the grating. Defaults to 0.5.\n    num_gratings : int, optional\n        The number of grating periods. Defaults to 3.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the grating pattern.\n    \"\"\"\n    width = pitch * num_gratings - pitch // 2\n    grating = np.zeros((height, width))\n    grating_width = int(pitch * duty_cycle)\n    for i in range(num_gratings):\n        start = i * pitch\n        grating[:, start : start + grating_width] = 1\n    return Device(device_array=grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes","title":"<code>holes(rows=5, cols=5, radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of uniform circular holes.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>radius</code> <code>int</code> <p>The radius of each hole. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circular holes.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes(\n    rows: int = 5, cols: int = 5, radius: int = 30, spacing: int = 30, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of uniform circular holes.\n\n    Parameters\n    ----------\n    rows : int, optional\n        The number of rows in the grid. Defaults to 5.\n    cols : int, optional\n        The number of columns in the grid. Defaults to 5.\n    radius : int, optional\n        The radius of each hole. Defaults to 30.\n    spacing : int, optional\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circular holes.\n    \"\"\"\n    grid_height = rows * (2 * radius + spacing) - spacing\n    grid_width = cols * (2 * radius + spacing) - spacing\n    holes = np.ones((grid_height, grid_width))\n    y, x = np.ogrid[-radius:radius, -radius:radius]\n    mask = x**2 + y**2 &lt;= radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * radius + spacing) + radius\n            center_x = col * (2 * radius + spacing) + radius\n            holes[\n                center_y - radius : center_y + radius,\n                center_x - radius : center_x + radius,\n            ][mask] = 0\n    return Device(device_array=holes, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes_offset","title":"<code>holes_offset(rows=5, cols=5, radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with an offset grid of circular holes.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>radius</code> <code>int</code> <p>The radius of each hole. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing an offset grid of circular holes.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes_offset(\n    rows: int = 5, cols: int = 5, radius: int = 30, spacing: int = 30, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grid of circular holes.\n\n    Parameters\n    ----------\n    rows : int, optional\n        The number of rows in the grid. Defaults to 5.\n    cols : int, optional\n        The number of columns in the grid. Defaults to 5.\n    radius : int, optional\n        The radius of each hole. Defaults to 30.\n    spacing : int, optional\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing an offset grid of circular holes.\n    \"\"\"\n    grid_height = rows * (2 * radius + spacing) - spacing\n    grid_width = cols * (2 * radius + spacing) - spacing + (radius + spacing // 2)\n    holes_offset = np.ones((grid_height, grid_width))\n    y, x = np.ogrid[-radius:radius, -radius:radius]\n    mask = x**2 + y**2 &lt;= radius**2\n    for row in range(rows):\n        for col in range(cols):\n            center_y = row * (2 * radius + spacing) + radius\n            center_x = (\n                col * (2 * radius + spacing)\n                + radius\n                + (radius + spacing // 2 if row % 2 == 1 else 0)\n            )\n            holes_offset[\n                center_y - radius : center_y + radius,\n                center_x - radius : center_x + radius,\n            ][mask] = 0\n    return Device(device_array=holes_offset, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.holes_varying","title":"<code>holes_varying(rows=5, cols=5, min_radius=10, max_radius=30, spacing=30, **kwargs)</code>","text":"<p>Create a Device object with a grid of circular holes with varying radii.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the grid. Defaults to 5.</p> <code>5</code> <code>cols</code> <code>int</code> <p>The number of columns in the grid. Defaults to 5.</p> <code>5</code> <code>min_radius</code> <code>int</code> <p>The minimum radius of the holes. Defaults to 10.</p> <code>10</code> <code>max_radius</code> <code>int</code> <p>The maximum radius of the holes. Defaults to 30.</p> <code>30</code> <code>spacing</code> <code>int</code> <p>The spacing between hole centers. Defaults to 30.</p> <code>30</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing a grid of circular holes with varying radii.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def holes_varying(\n    rows: int = 5,\n    cols: int = 5,\n    min_radius: int = 10,\n    max_radius: int = 30,\n    spacing: int = 30,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a grid of circular holes with varying radii.\n\n    Parameters\n    ----------\n    rows : int, optional\n        The number of rows in the grid. Defaults to 5.\n    cols : int, optional\n        The number of columns in the grid. Defaults to 5.\n    min_radius : int, optional\n        The minimum radius of the holes. Defaults to 10.\n    max_radius : int, optional\n        The maximum radius of the holes. Defaults to 30.\n    spacing : int, optional\n        The spacing between hole centers. Defaults to 30.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing a grid of circular holes with varying radii.\n    \"\"\"\n    grid_height = rows * (2 * max_radius + spacing) - spacing\n    grid_width = cols * (2 * max_radius + spacing) - spacing\n    holes_varying = np.ones((grid_height, grid_width))\n    radius_range = np.linspace(min_radius, max_radius, rows * cols).reshape(rows, cols)\n    for row in range(rows):\n        for col in range(cols):\n            radius = int(radius_range[row, col])\n            y, x = np.ogrid[-radius:radius, -radius:radius]\n            mask = x**2 + y**2 &lt;= radius**2\n            center_y = row * (2 * max_radius + spacing) + max_radius\n            center_x = col * (2 * max_radius + spacing) + max_radius\n            holes_varying[\n                center_y - radius : center_y + radius,\n                center_x - radius : center_x + radius,\n            ][mask] = 0\n    return Device(device_array=holes_varying, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.offset_grating","title":"<code>offset_grating(height=200, pitch=120, duty_cycle=0.5, num_gratings=3, **kwargs)</code>","text":"<p>Create a Device object with an offset grating pattern (alternating rows).</p> <p>Parameters:</p> Name Type Description Default <code>height</code> <code>int</code> <p>The height of the grating. Defaults to 200.</p> <code>200</code> <code>pitch</code> <code>int</code> <p>The pitch (period) of the grating. Defaults to 120.</p> <code>120</code> <code>duty_cycle</code> <code>float</code> <p>The duty cycle of the grating. Defaults to 0.5.</p> <code>0.5</code> <code>num_gratings</code> <code>int</code> <p>The number of grating periods. Defaults to 3.</p> <code>3</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the offset grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def offset_grating(\n    height: int = 200,\n    pitch: int = 120,\n    duty_cycle: float = 0.5,\n    num_gratings: int = 3,\n    **kwargs,\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with an offset grating pattern (alternating rows).\n\n    Parameters\n    ----------\n    height : int, optional\n        The height of the grating. Defaults to 200.\n    pitch : int, optional\n        The pitch (period) of the grating. Defaults to 120.\n    duty_cycle : float, optional\n        The duty cycle of the grating. Defaults to 0.5.\n    num_gratings : int, optional\n        The number of grating periods. Defaults to 3.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the offset grating pattern.\n    \"\"\"\n    width = pitch * num_gratings\n    grating = np.zeros((height, width))\n    grating_width = int(pitch * duty_cycle)\n    half_height = height // 2\n    for i in range(num_gratings):\n        start = i * pitch\n        grating[half_height:, start : start + grating_width] = 1\n    for i in range(num_gratings):\n        start = i * pitch + pitch // 2\n        grating[:half_height, start : start + grating_width] = 1\n    return Device(device_array=grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.pie","title":"<code>pie(width=200, arc_angle=270, **kwargs)</code>","text":"<p>Create a Device object with a pie shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width and height of the pie. Defaults to 200.</p> <code>200</code> <code>arc_angle</code> <code>float</code> <p>The angle of the pie slice in degrees. Defaults to 270.</p> <code>270</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the pie shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def pie(width: int = 200, arc_angle: float = 270, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a pie shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The width and height of the pie. Defaults to 200.\n    arc_angle : float, optional\n        The angle of the pie slice in degrees. Defaults to 270.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the pie shape.\n    \"\"\"\n    radius = width // 2\n    y, x = np.ogrid[-radius:radius, -radius:radius]\n    angle = np.arctan2(y, x) * 180 / np.pi\n    angle = (angle + 360) % 360\n    mask = (x**2 + y**2 &lt;= radius**2) &amp; (angle &lt;= arc_angle)\n    pie = np.zeros((width, width))\n    pie[mask] = 1\n    return Device(device_array=pie, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.poly","title":"<code>poly(width=200, num_points=5, **kwargs)</code>","text":"<p>Create a Device object with a regular polygon shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the polygon. Defaults to 200.</p> <code>200</code> <code>num_points</code> <code>int</code> <p>The number of sides of the polygon. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the regular polygon shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def poly(width: int = 200, num_points: int = 5, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a regular polygon shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the polygon. Defaults to 200.\n    num_points : int, optional\n        The number of sides of the polygon. Defaults to 5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the regular polygon shape.\n    \"\"\"\n    radius = width // 2\n    angles = np.linspace(0, 2 * np.pi, num_points, endpoint=False) - np.pi / 2\n    x = (radius * np.cos(angles) + radius).astype(int)\n    y = (radius * np.sin(angles) + radius).astype(int)\n    poly = np.zeros((width, width))\n    rr, cc = polygon(y, x)\n    rr = np.clip(rr, 0, width - 1)\n    cc = np.clip(cc, 0, width - 1)\n    poly[rr, cc] = 1\n    return Device(device_array=poly, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.radial_grating","title":"<code>radial_grating(width=200, grating_skew=0, num_gratings=6, **kwargs)</code>","text":"<p>Create a Device object with a radial grating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the radial grating. Defaults to 200.</p> <code>200</code> <code>grating_skew</code> <code>int</code> <p>The skew angle of the grating arms. Defaults to 0.</p> <code>0</code> <code>num_gratings</code> <code>int</code> <p>The number of grating arms. Defaults to 6.</p> <code>6</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the radial grating pattern.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def radial_grating(\n    width: int = 200, grating_skew: int = 0, num_gratings: int = 6, **kwargs\n) -&gt; Device:\n    \"\"\"\n    Create a Device object with a radial grating pattern.\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the radial grating. Defaults to 200.\n    grating_skew : int, optional\n        The skew angle of the grating arms. Defaults to 0.\n    num_gratings : int, optional\n        The number of grating arms. Defaults to 6.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the radial grating pattern.\n    \"\"\"\n    radial_grating = np.zeros((width, width))\n    center = width // 2\n    radius = center\n    theta = np.linspace(0, 2 * np.pi, num_gratings, endpoint=False)\n    for angle in theta:\n        x0, y0 = center, center\n        x1 = int(center + radius * np.cos(angle))\n        y1 = int(center + radius * np.sin(angle))\n        x2 = int(\n            center + (radius - grating_skew) * np.cos(angle + np.pi / num_gratings)\n        )\n        y2 = int(\n            center + (radius - grating_skew) * np.sin(angle + np.pi / num_gratings)\n        )\n        rr, cc = polygon([y0, y1, y2], [x0, x1, x2])\n        rr = np.clip(rr, 0, width - 1)\n        cc = np.clip(cc, 0, width - 1)\n        radial_grating[rr, cc] = 1\n    return Device(device_array=radial_grating, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.rectangle","title":"<code>rectangle(width=200, height=100, **kwargs)</code>","text":"<p>Create a Device object with a rectangular shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The width of the rectangle. Defaults to 200.</p> <code>200</code> <code>height</code> <code>int</code> <p>The height of the rectangle. Defaults to 100.</p> <code>100</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the rectangular shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def rectangle(width: int = 200, height: int = 100, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a rectangular shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The width of the rectangle. Defaults to 200.\n    height : int, optional\n        The height of the rectangle. Defaults to 100.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the rectangular shape.\n    \"\"\"\n    rectangle = np.zeros((height, width))\n    rectangle[:, :] = 1\n    return Device(device_array=rectangle, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.ring","title":"<code>ring(width=200, border_width=60, **kwargs)</code>","text":"<p>Create a Device object with a ring shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the ring. Defaults to 200.</p> <code>200</code> <code>border_width</code> <code>int</code> <p>The width of the ring border. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the ring shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def ring(width: int = 200, border_width: int = 60, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a ring shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the ring. Defaults to 200.\n    border_width : int, optional\n        The width of the ring border. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the ring shape.\n    \"\"\"\n    radius_outer = width // 2\n    radius_inner = radius_outer - border_width\n    y, x = np.ogrid[-radius_outer:radius_outer, -radius_outer:radius_outer]\n    distance_from_center = np.sqrt(x**2 + y**2)\n    mask = (distance_from_center &lt;= radius_outer) &amp; (\n        distance_from_center &gt;= radius_inner\n    )\n    ring = np.zeros((width, width))\n    ring[mask] = 1\n    return Device(device_array=ring, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.star","title":"<code>star(width=200, num_points=5, **kwargs)</code>","text":"<p>Create a Device object with a star shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the star. Defaults to 200.</p> <code>200</code> <code>num_points</code> <code>int</code> <p>The number of points on the star. Defaults to 5.</p> <code>5</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the star shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def star(width: int = 200, num_points: int = 5, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a star shape.\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the star. Defaults to 200.\n    num_points : int, optional\n        The number of points on the star. Defaults to 5.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the star shape.\n    \"\"\"\n    radius_outer = width // 2\n    radius_inner = radius_outer // 2\n    angles_outer = np.linspace(0, 2 * np.pi, num_points, endpoint=False) - np.pi / 2\n    angles_inner = angles_outer + np.pi / num_points\n    x_outer = (radius_outer * np.cos(angles_outer) + radius_outer).astype(int)\n    y_outer = (radius_outer * np.sin(angles_outer) + radius_outer).astype(int)\n    x_inner = (radius_inner * np.cos(angles_inner) + radius_outer).astype(int)\n    y_inner = (radius_inner * np.sin(angles_inner) + radius_outer).astype(int)\n    x = np.empty(2 * num_points, dtype=int)\n    y = np.empty(2 * num_points, dtype=int)\n    x[0::2] = x_outer\n    x[1::2] = x_inner\n    y[0::2] = y_outer\n    y[1::2] = y_inner\n    star = np.zeros((width, width))\n    rr, cc = polygon(y, x)\n    rr = np.clip(rr, 0, width - 1)\n    cc = np.clip(cc, 0, width - 1)\n    star[rr, cc] = 1\n    return Device(device_array=star, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.target","title":"<code>target(width=200, arm_width=60, **kwargs)</code>","text":"<p>Create a Device object with a target shape (cross with center removed).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the target. Defaults to 200.</p> <code>200</code> <code>arm_width</code> <code>int</code> <p>The width of the target arms. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the target shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def target(width: int = 200, arm_width: int = 60, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a target shape (cross with center removed).\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the target. Defaults to 200.\n    arm_width : int, optional\n        The width of the target arms. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the target shape.\n    \"\"\"\n    target = np.zeros((width, width))\n    center = width // 2\n    half_arm_width = arm_width // 2\n    target[center - half_arm_width : center + half_arm_width + 1, :] = 1\n    target[:, center - half_arm_width : center + half_arm_width + 1] = 1\n    target[\n        center - half_arm_width : center + half_arm_width + 1,\n        center - half_arm_width : center + half_arm_width + 1,\n    ] = 0\n    return Device(device_array=target, **kwargs)\n</code></pre>"},{"location":"reference/shapes/#prefab.shapes.window","title":"<code>window(width=200, border_width=60, **kwargs)</code>","text":"<p>Create a Device object with a window shape (hollow square).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The overall width and height of the window. Defaults to 200.</p> <code>200</code> <code>border_width</code> <code>int</code> <p>The width of the window border. Defaults to 60.</p> <code>60</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to be passed to the Device constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Device</code> <p>A Device object containing the window shape.</p> Source code in <code>prefab/shapes.py</code> <pre><code>def window(width: int = 200, border_width: int = 60, **kwargs) -&gt; Device:\n    \"\"\"\n    Create a Device object with a window shape (hollow square).\n\n    Parameters\n    ----------\n    width : int, optional\n        The overall width and height of the window. Defaults to 200.\n    border_width : int, optional\n        The width of the window border. Defaults to 60.\n    **kwargs : dict\n        Additional keyword arguments to be passed to the Device constructor.\n\n    Returns\n    -------\n    Device\n        A Device object containing the window shape.\n    \"\"\"\n    window = np.zeros((width, width))\n    window[:border_width, :] = 1\n    window[-border_width:, :] = 1\n    window[:, :border_width] = 1\n    window[:, -border_width:] = 1\n    return Device(device_array=window, **kwargs)\n</code></pre>"}]}